
;;;;    tfnsw-gtfs-realtime.lisp

;;; Generated by the protocol buffer compiler.  DO NOT EDIT!


(cl:in-package #:common-lisp-user)
(eval-when (:compile-toplevel :load-toplevel :execute)
  (unless (find-package '#:transit-realtime)
    (make-package '#:transit-realtime :use nil)))
(in-package #:transit-realtime)
(cl:declaim #.com.google.base:*optimize-default*)

(cl:deftype feed-header-incrementality () '(cl:member 0 1))
(cl:export 'feed-header-incrementality)

(cl:defconstant +feed-header-incrementality-full-dataset+ 0)
(cl:export '+feed-header-incrementality-full-dataset+)
(cl:defconstant +feed-header-incrementality-differential+ 1)
(cl:export '+feed-header-incrementality-differential+)

(cl:defconstant +minimum-feed-header-incrementality+ +feed-header-incrementality-full-dataset+)
(cl:export '+minimum-feed-header-incrementality+)
(cl:defconstant +maximum-feed-header-incrementality+ +feed-header-incrementality-differential+)
(cl:export '+maximum-feed-header-incrementality+)

(cl:deftype trip-update-stop-time-update-schedule-relationship () '(cl:member 0 1 2))
(cl:export 'trip-update-stop-time-update-schedule-relationship)

(cl:defconstant +trip-update-stop-time-update-schedule-relationship-scheduled+ 0)
(cl:export '+trip-update-stop-time-update-schedule-relationship-scheduled+)
(cl:defconstant +trip-update-stop-time-update-schedule-relationship-skipped+ 1)
(cl:export '+trip-update-stop-time-update-schedule-relationship-skipped+)
(cl:defconstant +trip-update-stop-time-update-schedule-relationship-no-data+ 2)
(cl:export '+trip-update-stop-time-update-schedule-relationship-no-data+)

(cl:defconstant +minimum-trip-update-stop-time-update-schedule-relationship+ +trip-update-stop-time-update-schedule-relationship-scheduled+)
(cl:export '+minimum-trip-update-stop-time-update-schedule-relationship+)
(cl:defconstant +maximum-trip-update-stop-time-update-schedule-relationship+ +trip-update-stop-time-update-schedule-relationship-no-data+)
(cl:export '+maximum-trip-update-stop-time-update-schedule-relationship+)

(cl:deftype vehicle-position-vehicle-stop-status () '(cl:member 0 1 2))
(cl:export 'vehicle-position-vehicle-stop-status)

(cl:defconstant +vehicle-position-vehicle-stop-status-incoming-at+ 0)
(cl:export '+vehicle-position-vehicle-stop-status-incoming-at+)
(cl:defconstant +vehicle-position-vehicle-stop-status-stopped-at+ 1)
(cl:export '+vehicle-position-vehicle-stop-status-stopped-at+)
(cl:defconstant +vehicle-position-vehicle-stop-status-in-transit-to+ 2)
(cl:export '+vehicle-position-vehicle-stop-status-in-transit-to+)

(cl:defconstant +minimum-vehicle-position-vehicle-stop-status+ +vehicle-position-vehicle-stop-status-incoming-at+)
(cl:export '+minimum-vehicle-position-vehicle-stop-status+)
(cl:defconstant +maximum-vehicle-position-vehicle-stop-status+ +vehicle-position-vehicle-stop-status-in-transit-to+)
(cl:export '+maximum-vehicle-position-vehicle-stop-status+)

(cl:deftype vehicle-position-congestion-level () '(cl:member 0 1 2 3 4))
(cl:export 'vehicle-position-congestion-level)

(cl:defconstant +vehicle-position-congestion-level-unknown-congestion-level+ 0)
(cl:export '+vehicle-position-congestion-level-unknown-congestion-level+)
(cl:defconstant +vehicle-position-congestion-level-running-smoothly+ 1)
(cl:export '+vehicle-position-congestion-level-running-smoothly+)
(cl:defconstant +vehicle-position-congestion-level-stop-and-go+ 2)
(cl:export '+vehicle-position-congestion-level-stop-and-go+)
(cl:defconstant +vehicle-position-congestion-level-congestion+ 3)
(cl:export '+vehicle-position-congestion-level-congestion+)
(cl:defconstant +vehicle-position-congestion-level-severe-congestion+ 4)
(cl:export '+vehicle-position-congestion-level-severe-congestion+)

(cl:defconstant +minimum-vehicle-position-congestion-level+ +vehicle-position-congestion-level-unknown-congestion-level+)
(cl:export '+minimum-vehicle-position-congestion-level+)
(cl:defconstant +maximum-vehicle-position-congestion-level+ +vehicle-position-congestion-level-severe-congestion+)
(cl:export '+maximum-vehicle-position-congestion-level+)

(cl:deftype vehicle-position-occupancy-status () '(cl:member 0 1 2 3 4 5 6))
(cl:export 'vehicle-position-occupancy-status)

(cl:defconstant +vehicle-position-occupancy-status-empty+ 0)
(cl:export '+vehicle-position-occupancy-status-empty+)
(cl:defconstant +vehicle-position-occupancy-status-many-seats-available+ 1)
(cl:export '+vehicle-position-occupancy-status-many-seats-available+)
(cl:defconstant +vehicle-position-occupancy-status-few-seats-available+ 2)
(cl:export '+vehicle-position-occupancy-status-few-seats-available+)
(cl:defconstant +vehicle-position-occupancy-status-standing-room-only+ 3)
(cl:export '+vehicle-position-occupancy-status-standing-room-only+)
(cl:defconstant +vehicle-position-occupancy-status-crushed-standing-room-only+ 4)
(cl:export '+vehicle-position-occupancy-status-crushed-standing-room-only+)
(cl:defconstant +vehicle-position-occupancy-status-full+ 5)
(cl:export '+vehicle-position-occupancy-status-full+)
(cl:defconstant +vehicle-position-occupancy-status-not-accepting-passengers+ 6)
(cl:export '+vehicle-position-occupancy-status-not-accepting-passengers+)

(cl:defconstant +minimum-vehicle-position-occupancy-status+ +vehicle-position-occupancy-status-empty+)
(cl:export '+minimum-vehicle-position-occupancy-status+)
(cl:defconstant +maximum-vehicle-position-occupancy-status+ +vehicle-position-occupancy-status-not-accepting-passengers+)
(cl:export '+maximum-vehicle-position-occupancy-status+)

(cl:deftype alert-cause () '(cl:member 1 2 3 4 5 6 7 8 9 10 11 12))
(cl:export 'alert-cause)

(cl:defconstant +alert-cause-unknown-cause+ 1)
(cl:export '+alert-cause-unknown-cause+)
(cl:defconstant +alert-cause-other-cause+ 2)
(cl:export '+alert-cause-other-cause+)
(cl:defconstant +alert-cause-technical-problem+ 3)
(cl:export '+alert-cause-technical-problem+)
(cl:defconstant +alert-cause-strike+ 4)
(cl:export '+alert-cause-strike+)
(cl:defconstant +alert-cause-demonstration+ 5)
(cl:export '+alert-cause-demonstration+)
(cl:defconstant +alert-cause-accident+ 6)
(cl:export '+alert-cause-accident+)
(cl:defconstant +alert-cause-holiday+ 7)
(cl:export '+alert-cause-holiday+)
(cl:defconstant +alert-cause-weather+ 8)
(cl:export '+alert-cause-weather+)
(cl:defconstant +alert-cause-maintenance+ 9)
(cl:export '+alert-cause-maintenance+)
(cl:defconstant +alert-cause-construction+ 10)
(cl:export '+alert-cause-construction+)
(cl:defconstant +alert-cause-police-activity+ 11)
(cl:export '+alert-cause-police-activity+)
(cl:defconstant +alert-cause-medical-emergency+ 12)
(cl:export '+alert-cause-medical-emergency+)

(cl:defconstant +minimum-alert-cause+ +alert-cause-unknown-cause+)
(cl:export '+minimum-alert-cause+)
(cl:defconstant +maximum-alert-cause+ +alert-cause-medical-emergency+)
(cl:export '+maximum-alert-cause+)

(cl:deftype alert-effect () '(cl:member 1 2 3 4 5 6 7 8 9))
(cl:export 'alert-effect)

(cl:defconstant +alert-effect-no-service+ 1)
(cl:export '+alert-effect-no-service+)
(cl:defconstant +alert-effect-reduced-service+ 2)
(cl:export '+alert-effect-reduced-service+)
(cl:defconstant +alert-effect-significant-delays+ 3)
(cl:export '+alert-effect-significant-delays+)
(cl:defconstant +alert-effect-detour+ 4)
(cl:export '+alert-effect-detour+)
(cl:defconstant +alert-effect-additional-service+ 5)
(cl:export '+alert-effect-additional-service+)
(cl:defconstant +alert-effect-modified-service+ 6)
(cl:export '+alert-effect-modified-service+)
(cl:defconstant +alert-effect-other-effect+ 7)
(cl:export '+alert-effect-other-effect+)
(cl:defconstant +alert-effect-unknown-effect+ 8)
(cl:export '+alert-effect-unknown-effect+)
(cl:defconstant +alert-effect-stop-moved+ 9)
(cl:export '+alert-effect-stop-moved+)

(cl:defconstant +minimum-alert-effect+ +alert-effect-no-service+)
(cl:export '+minimum-alert-effect+)
(cl:defconstant +maximum-alert-effect+ +alert-effect-stop-moved+)
(cl:export '+maximum-alert-effect+)

(cl:deftype trip-descriptor-schedule-relationship () '(cl:member 0 1 2 3))
(cl:export 'trip-descriptor-schedule-relationship)

(cl:defconstant +trip-descriptor-schedule-relationship-scheduled+ 0)
(cl:export '+trip-descriptor-schedule-relationship-scheduled+)
(cl:defconstant +trip-descriptor-schedule-relationship-added+ 1)
(cl:export '+trip-descriptor-schedule-relationship-added+)
(cl:defconstant +trip-descriptor-schedule-relationship-unscheduled+ 2)
(cl:export '+trip-descriptor-schedule-relationship-unscheduled+)
(cl:defconstant +trip-descriptor-schedule-relationship-canceled+ 3)
(cl:export '+trip-descriptor-schedule-relationship-canceled+)

(cl:defconstant +minimum-trip-descriptor-schedule-relationship+ +trip-descriptor-schedule-relationship-scheduled+)
(cl:export '+minimum-trip-descriptor-schedule-relationship+)
(cl:defconstant +maximum-trip-descriptor-schedule-relationship+ +trip-descriptor-schedule-relationship-canceled+)
(cl:export '+maximum-trip-descriptor-schedule-relationship+)

(cl:defclass feed-message (pb:protocol-buffer)
  (
  (header
   :accessor header
   :initform cl:nil
   :type (cl:or cl:null transit-realtime::feed-header))
  (entity
   :accessor entity
   :initform (cl:make-array
              0
              :element-type 'transit-realtime::feed-entity
              :fill-pointer 0 :adjustable cl:t)
   :type (cl:vector transit-realtime::feed-entity))
  (%has-bits%
   :accessor %has-bits%
   :initform 0
   :type (cl:unsigned-byte 2))
  (pb::%cached-size%
   :initform 0
   :type (cl:integer 0 #.(cl:1- cl:array-dimension-limit)))
  ))

(cl:export 'feed-message)

(cl:export 'header)


(cl:defmethod (cl:setf header) :after (x (self feed-message))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-header)
  (cl:defgeneric has-header (proto)))
(cl:defmethod has-header ((self feed-message))
  (cl:logbitp 0 (cl:slot-value self '%has-bits%)))
(cl:export 'has-header)

(cl:unless (cl:fboundp 'clear-header)
  (cl:defgeneric clear-header (proto)))
(cl:defmethod clear-header ((self feed-message))
  (cl:setf (cl:slot-value self 'header) cl:nil)
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-header)

(cl:export 'entity)

(cl:unless (cl:fboundp 'clear-entity)
  (cl:defgeneric clear-entity (proto)))
(cl:defmethod clear-entity ((self feed-message))
  (cl:setf (cl:slot-value self 'entity)
           (cl:make-array 0 :element-type 'transit-realtime::feed-entity
            :fill-pointer 0 :adjustable cl:t))
  (cl:values))
(cl:export 'clear-entity)


(cl:defmethod cl:print-object ((self feed-message) stream)
  (cl:pprint-logical-block (stream cl:nil)
    (cl:print-unreadable-object (self stream :type cl:t :identity cl:t)
      (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_header: ~s" (header self)))
      (cl:format stream " ~_entity: ~s" (entity self))
      ))
  (cl:values))

(cl:defmethod pb:clear ((self feed-message))
  (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'header) cl:nil))
  (cl:setf (cl:slot-value self 'entity)
           (cl:make-array 0 :element-type 'transit-realtime::feed-entity
            :fill-pointer 0 :adjustable cl:t))
  (cl:setf (cl:slot-value self '%has-bits%) 0)
  (cl:values))

(cl:defmethod pb:is-initialized ((self feed-message))
  (cl:when (cl:/= (cl:logand (cl:slot-value self '%has-bits%)
                             #b01)
                  #b01)
    (cl:return-from pb:is-initialized cl:nil))
  (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
    (cl:unless (pb:is-initialized (cl:slot-value self 'header))
      (cl:return-from pb:is-initialized cl:nil)))
  (cl:let* ((x (cl:slot-value self 'entity))
            (length (cl:length x)))
    (cl:dotimes (i length)
      (cl:unless (pb:is-initialized (cl:aref x i))
        (cl:return-from pb:is-initialized cl:nil))))
  cl:t)

(cl:defmethod pb:octet-size ((self feed-message))
  (cl:let ((size 0))
    ;; required .transit_realtime.FeedHeader header = 1[json_name = "header"];
    (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
      (cl:let ((s (pb:octet-size (cl:slot-value self 'header))))
        (cl:incf size (cl:+ 1 s (varint:length32 s)))))
    ;; repeated .transit_realtime.FeedEntity entity = 2[json_name = "entity"];
    (cl:let* ((v (cl:slot-value self 'entity))
              (length (cl:length v)))
      (cl:incf size (cl:* 1 length))
      (cl:dotimes (i length)
        (cl:let ((s (pb:octet-size (cl:aref v i))))
          (cl:incf size (cl:+ s (varint:length32 s))))))
    (cl:setf (cl:slot-value self 'pb::%cached-size%) size)
    size))

(cl:defmethod pb:serialize ((self feed-message) buffer index limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index index limit)
              (cl:ignorable buffer limit))
  ;; required .transit_realtime.FeedHeader header = 1[json_name = "header"];
  (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 10))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit (cl:slot-value (cl:slot-value self 'header) 'pb::%cached-size%)))
    (cl:setf index (pb:serialize (cl:slot-value self 'header) buffer index limit)))
  ;; repeated .transit_realtime.FeedEntity entity = 2[json_name = "entity"];
  (cl:let* ((v (cl:slot-value self 'entity))
            (length (cl:length v)))
    (cl:loop for i from 0 below length do
       (cl:setf index (varint:encode-uint32-carefully buffer index limit 18))
       (cl:setf index (varint:encode-uint32-carefully buffer index limit (cl:slot-value (cl:aref v i) 'pb::%cached-size%)))
       (cl:setf index (pb:serialize (cl:aref v i) buffer index limit))))
  ;// Extension range [1000, 2000)
  ;DO_(_extensions_.SerializeWithCachedSizes(
  ;    1000, 2000, *this, output));

  index)

(cl:defmethod pb:merge-from-array ((self feed-message) buffer start limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index start limit))
  (cl:do ((index start index))
      ((cl:>= index limit) index)
    (cl:declare (cl:type com.google.base:vector-index index))
    (cl:multiple-value-bind (tag new-index)
        (varint:parse-uint32-carefully buffer index limit)
      (cl:setf index new-index)
      (cl:case tag
        ;; required .transit_realtime.FeedHeader header = 1[json_name = "header"];
        ((10)
          (cl:multiple-value-bind (length new-index)
              (varint:parse-uint31-carefully buffer index limit)
            (cl:when (cl:> (cl:+ new-index length) limit)
              (cl:error "buffer overflow"))
            (cl:let ((message (cl:slot-value self 'header)))
              (cl:when (cl:null message)
                (cl:setf message (cl:make-instance 'transit-realtime::feed-header))
                (cl:setf (cl:slot-value self 'header) message)
                (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))
              (cl:setf index (pb:merge-from-array message buffer new-index (cl:+ new-index length)))
              (cl:when (cl:not (cl:= index (cl:+ new-index length)))
                (cl:error "buffer overflow")))))
        ;; repeated .transit_realtime.FeedEntity entity = 2[json_name = "entity"];
        ((18)
          (cl:multiple-value-bind (length new-index)
              (varint:parse-uint31-carefully buffer index limit)
            (cl:when (cl:> (cl:+ new-index length) limit)
              (cl:error "buffer overflow"))
            (cl:let ((message (cl:make-instance 'transit-realtime::feed-entity)))
              (cl:setf index (pb:merge-from-array message buffer new-index (cl:+ new-index length)))
              (cl:when (cl:not (cl:= index (cl:+ new-index length)))
                (cl:error "buffer overflow"))
              (cl:vector-push-extend message (cl:slot-value self 'entity)))))
        (cl:t
          (cl:when (cl:= (cl:logand tag 7) 4)
            (cl:return-from pb:merge-from-array index))
          (cl:setf index (wire-format:skip-field buffer index limit tag)))))))

(cl:defmethod pb:merge-from-message ((self feed-message) (from feed-message))
  (cl:let* ((v (cl:slot-value self 'entity))
            (vf (cl:slot-value from 'entity))
            (length (cl:length vf)))
    (cl:loop for i from 0 below length do
      (cl:vector-push-extend (cl:aref vf i) v)))
  (cl:when (cl:logbitp 0 (cl:slot-value from '%has-bits%))
    (cl:let ((message (cl:slot-value self 'header)))
      (cl:when (cl:null message)
        (cl:setf message (cl:make-instance 'transit-realtime::feed-header))
        (cl:setf (cl:slot-value self 'header) message)
        (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))
     (pb:merge-from-message message (cl:slot-value from 'header))))
)


(cl:defclass feed-header (pb:protocol-buffer)
  (
  (gtfs-realtime-version
   :accessor gtfs-realtime-version
   :initform (pb:string-field "")
   :type pb::%sf%)
  (incrementality
   :accessor incrementality
   :initform transit-realtime::+feed-header-incrementality-full-dataset+
   :type transit-realtime::feed-header-incrementality)
  (timestamp
   :accessor timestamp
   :initform 0
   :type (cl:unsigned-byte 64))
  (%has-bits%
   :accessor %has-bits%
   :initform 0
   :type (cl:unsigned-byte 3))
  (pb::%cached-size%
   :initform 0
   :type (cl:integer 0 #.(cl:1- cl:array-dimension-limit)))
  ))

(cl:export 'feed-header)

(cl:export 'gtfs-realtime-version)


(cl:defmethod (cl:setf gtfs-realtime-version) :after (x (self feed-header))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-gtfs-realtime-version)
  (cl:defgeneric has-gtfs-realtime-version (proto)))
(cl:defmethod has-gtfs-realtime-version ((self feed-header))
  (cl:logbitp 0 (cl:slot-value self '%has-bits%)))
(cl:export 'has-gtfs-realtime-version)

(cl:unless (cl:fboundp 'clear-gtfs-realtime-version)
  (cl:defgeneric clear-gtfs-realtime-version (proto)))
(cl:defmethod clear-gtfs-realtime-version ((self feed-header))
  (cl:setf (cl:slot-value self 'gtfs-realtime-version) (pb:string-field ""))
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-gtfs-realtime-version)

(cl:export 'incrementality)


(cl:defmethod (cl:setf incrementality) :after (x (self feed-header))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-incrementality)
  (cl:defgeneric has-incrementality (proto)))
(cl:defmethod has-incrementality ((self feed-header))
  (cl:logbitp 1 (cl:slot-value self '%has-bits%)))
(cl:export 'has-incrementality)

(cl:unless (cl:fboundp 'clear-incrementality)
  (cl:defgeneric clear-incrementality (proto)))
(cl:defmethod clear-incrementality ((self feed-header))
  (cl:setf (cl:slot-value self 'incrementality) transit-realtime::+feed-header-incrementality-full-dataset+)
  (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-incrementality)

(cl:export 'timestamp)


(cl:defmethod (cl:setf timestamp) :after (x (self feed-header))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-timestamp)
  (cl:defgeneric has-timestamp (proto)))
(cl:defmethod has-timestamp ((self feed-header))
  (cl:logbitp 2 (cl:slot-value self '%has-bits%)))
(cl:export 'has-timestamp)

(cl:unless (cl:fboundp 'clear-timestamp)
  (cl:defgeneric clear-timestamp (proto)))
(cl:defmethod clear-timestamp ((self feed-header))
  (cl:setf (cl:slot-value self 'timestamp) 0)
  (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-timestamp)


(cl:defmethod cl:print-object ((self feed-header) stream)
  (cl:pprint-logical-block (stream cl:nil)
    (cl:print-unreadable-object (self stream :type cl:t :identity cl:t)
      (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_gtfs-realtime-version: ~s" (gtfs-realtime-version self)))
      (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_incrementality: ~s" (incrementality self)))
      (cl:when (cl:logbitp 2 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_timestamp: ~s" (timestamp self)))
      ))
  (cl:values))

(cl:defmethod pb:clear ((self feed-header))
  (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'gtfs-realtime-version) (pb:string-field "")))
  (cl:setf (cl:slot-value self 'incrementality) transit-realtime::+feed-header-incrementality-full-dataset+)
  (cl:setf (cl:slot-value self 'timestamp) 0)
  (cl:setf (cl:slot-value self '%has-bits%) 0)
  (cl:values))

(cl:defmethod pb:is-initialized ((self feed-header))
  (cl:when (cl:/= (cl:logand (cl:slot-value self '%has-bits%)
                             #b001)
                  #b001)
    (cl:return-from pb:is-initialized cl:nil))
  cl:t)

(cl:defmethod pb:octet-size ((self feed-header))
  (cl:let ((size 0))
    ;; required string gtfs_realtime_version = 1[json_name = "gtfsRealtimeVersion"];
    (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
      (cl:incf size 1)
      (cl:incf size (cl:let ((s (pb::%utf8-string-length% (cl:slot-value self 'gtfs-realtime-version))))
        (cl:+ s (varint:length32 s)))))
    ;; optional .transit_realtime.FeedHeader.Incrementality incrementality = 2 [default = FULL_DATASET, json_name = "incrementality"];
    (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
      (cl:incf size 1)
      (cl:incf size (varint:length64 (cl:ldb (cl:byte 64 0) (cl:slot-value self 'incrementality)))))
    ;; optional uint64 timestamp = 3[json_name = "timestamp"];
    (cl:when (cl:logbitp 2 (cl:slot-value self '%has-bits%))
      (cl:incf size
        (cl:+ 1 (varint:length64 (cl:slot-value self 'timestamp)))))
    (cl:setf (cl:slot-value self 'pb::%cached-size%) size)
    size))

(cl:defmethod pb:serialize ((self feed-header) buffer index limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index index limit)
              (cl:ignorable buffer limit))
  ;; required string gtfs_realtime_version = 1[json_name = "gtfsRealtimeVersion"];
  (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 10))
    (cl:setf index (wire-format:write-octets-carefully buffer index limit (cl:slot-value (cl:slot-value self 'gtfs-realtime-version) 'pb::%octets%))))
  ;; optional .transit_realtime.FeedHeader.Incrementality incrementality = 2 [default = FULL_DATASET, json_name = "incrementality"];
  (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 16))
    (cl:setf index
     (varint:encode-uint64-carefully buffer index limit
      (cl:ldb (cl:byte 64 0) (cl:slot-value self 'incrementality)))))
  ;; optional uint64 timestamp = 3[json_name = "timestamp"];
  (cl:when (cl:logbitp 2 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 24))
    (cl:setf index (varint:encode-uint64-carefully buffer index limit (cl:slot-value self 'timestamp))))
  ;// Extension range [1000, 2000)
  ;DO_(_extensions_.SerializeWithCachedSizes(
  ;    1000, 2000, *this, output));

  index)

(cl:defmethod pb:merge-from-array ((self feed-header) buffer start limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index start limit))
  (cl:do ((index start index))
      ((cl:>= index limit) index)
    (cl:declare (cl:type com.google.base:vector-index index))
    (cl:multiple-value-bind (tag new-index)
        (varint:parse-uint32-carefully buffer index limit)
      (cl:setf index new-index)
      (cl:case tag
        ;; required string gtfs_realtime_version = 1[json_name = "gtfsRealtimeVersion"];
        ((10)
          (cl:multiple-value-bind (value new-index)
              (wire-format:read-octets-carefully buffer index limit)
            (cl:setf (cl:slot-value self 'gtfs-realtime-version) (pb:string-field value))
            (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        ;; optional .transit_realtime.FeedHeader.Incrementality incrementality = 2 [default = FULL_DATASET, json_name = "incrementality"];
        ((16)
          (cl:multiple-value-bind (value new-index)
              (varint:parse-int32-carefully buffer index limit)
            ;; XXXXX: when valid, set field, else add to unknown fields
            (cl:setf (cl:slot-value self 'incrementality) value)
            (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        ;; optional uint64 timestamp = 3[json_name = "timestamp"];
        ((24)
          (cl:multiple-value-bind (value new-index)
              (varint:parse-uint64-carefully buffer index limit)
            (cl:setf (cl:slot-value self 'timestamp) value)
            (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        (cl:t
          (cl:when (cl:= (cl:logand tag 7) 4)
            (cl:return-from pb:merge-from-array index))
          (cl:setf index (wire-format:skip-field buffer index limit tag)))))))

(cl:defmethod pb:merge-from-message ((self feed-header) (from feed-header))
  (cl:when (cl:logbitp 0 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'gtfs-realtime-version) (cl:slot-value from 'gtfs-realtime-version))
    (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))
  (cl:when (cl:logbitp 1 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'incrementality) (cl:slot-value from 'incrementality))
    (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1))
  (cl:when (cl:logbitp 2 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'timestamp) (cl:slot-value from 'timestamp))
    (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 1))
)


(cl:defclass feed-entity (pb:protocol-buffer)
  (
  (id
   :accessor id
   :initform (pb:string-field "")
   :type pb::%sf%)
  (is-deleted
   :accessor is-deleted
   :initform cl:nil
   :type cl:boolean)
  (trip-update
   :accessor trip-update
   :initform cl:nil
   :type (cl:or cl:null transit-realtime::trip-update))
  (vehicle
   :accessor vehicle
   :initform cl:nil
   :type (cl:or cl:null transit-realtime::vehicle-position))
  (alert
   :accessor alert
   :initform cl:nil
   :type (cl:or cl:null transit-realtime::alert))
  (%has-bits%
   :accessor %has-bits%
   :initform 0
   :type (cl:unsigned-byte 5))
  (pb::%cached-size%
   :initform 0
   :type (cl:integer 0 #.(cl:1- cl:array-dimension-limit)))
  ))

(cl:export 'feed-entity)

(cl:export 'id)


(cl:defmethod (cl:setf id) :after (x (self feed-entity))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-id)
  (cl:defgeneric has-id (proto)))
(cl:defmethod has-id ((self feed-entity))
  (cl:logbitp 0 (cl:slot-value self '%has-bits%)))
(cl:export 'has-id)

(cl:unless (cl:fboundp 'clear-id)
  (cl:defgeneric clear-id (proto)))
(cl:defmethod clear-id ((self feed-entity))
  (cl:setf (cl:slot-value self 'id) (pb:string-field ""))
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-id)

(cl:export 'is-deleted)


(cl:defmethod (cl:setf is-deleted) :after (x (self feed-entity))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-is-deleted)
  (cl:defgeneric has-is-deleted (proto)))
(cl:defmethod has-is-deleted ((self feed-entity))
  (cl:logbitp 1 (cl:slot-value self '%has-bits%)))
(cl:export 'has-is-deleted)

(cl:unless (cl:fboundp 'clear-is-deleted)
  (cl:defgeneric clear-is-deleted (proto)))
(cl:defmethod clear-is-deleted ((self feed-entity))
  (cl:setf (cl:slot-value self 'is-deleted) cl:nil)
  (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-is-deleted)

(cl:export 'trip-update)


(cl:defmethod (cl:setf trip-update) :after (x (self feed-entity))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-trip-update)
  (cl:defgeneric has-trip-update (proto)))
(cl:defmethod has-trip-update ((self feed-entity))
  (cl:logbitp 2 (cl:slot-value self '%has-bits%)))
(cl:export 'has-trip-update)

(cl:unless (cl:fboundp 'clear-trip-update)
  (cl:defgeneric clear-trip-update (proto)))
(cl:defmethod clear-trip-update ((self feed-entity))
  (cl:setf (cl:slot-value self 'trip-update) cl:nil)
  (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-trip-update)

(cl:export 'vehicle)


(cl:defmethod (cl:setf vehicle) :after (x (self feed-entity))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 3) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-vehicle)
  (cl:defgeneric has-vehicle (proto)))
(cl:defmethod has-vehicle ((self feed-entity))
  (cl:logbitp 3 (cl:slot-value self '%has-bits%)))
(cl:export 'has-vehicle)

(cl:unless (cl:fboundp 'clear-vehicle)
  (cl:defgeneric clear-vehicle (proto)))
(cl:defmethod clear-vehicle ((self feed-entity))
  (cl:setf (cl:slot-value self 'vehicle) cl:nil)
  (cl:setf (cl:ldb (cl:byte 1 3) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-vehicle)

(cl:export 'alert)


(cl:defmethod (cl:setf alert) :after (x (self feed-entity))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 4) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-alert)
  (cl:defgeneric has-alert (proto)))
(cl:defmethod has-alert ((self feed-entity))
  (cl:logbitp 4 (cl:slot-value self '%has-bits%)))
(cl:export 'has-alert)

(cl:unless (cl:fboundp 'clear-alert)
  (cl:defgeneric clear-alert (proto)))
(cl:defmethod clear-alert ((self feed-entity))
  (cl:setf (cl:slot-value self 'alert) cl:nil)
  (cl:setf (cl:ldb (cl:byte 1 4) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-alert)


(cl:defmethod cl:print-object ((self feed-entity) stream)
  (cl:pprint-logical-block (stream cl:nil)
    (cl:print-unreadable-object (self stream :type cl:t :identity cl:t)
      (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_id: ~s" (id self)))
      (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_is-deleted: ~s" (is-deleted self)))
      (cl:when (cl:logbitp 2 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_trip-update: ~s" (trip-update self)))
      (cl:when (cl:logbitp 3 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_vehicle: ~s" (vehicle self)))
      (cl:when (cl:logbitp 4 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_alert: ~s" (alert self)))
      ))
  (cl:values))

(cl:defmethod pb:clear ((self feed-entity))
  (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'id) (pb:string-field "")))
  (cl:setf (cl:slot-value self 'is-deleted) cl:nil)
  (cl:when (cl:logbitp 2 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'trip-update) cl:nil))
  (cl:when (cl:logbitp 3 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'vehicle) cl:nil))
  (cl:when (cl:logbitp 4 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'alert) cl:nil))
  (cl:setf (cl:slot-value self '%has-bits%) 0)
  (cl:values))

(cl:defmethod pb:is-initialized ((self feed-entity))
  (cl:when (cl:/= (cl:logand (cl:slot-value self '%has-bits%)
                             #b00001)
                  #b00001)
    (cl:return-from pb:is-initialized cl:nil))
  (cl:when (cl:logbitp 2 (cl:slot-value self '%has-bits%))
    (cl:unless (pb:is-initialized (cl:slot-value self 'trip-update))
      (cl:return-from pb:is-initialized cl:nil)))
  (cl:when (cl:logbitp 3 (cl:slot-value self '%has-bits%))
    (cl:unless (pb:is-initialized (cl:slot-value self 'vehicle))
      (cl:return-from pb:is-initialized cl:nil)))
  (cl:when (cl:logbitp 4 (cl:slot-value self '%has-bits%))
    (cl:unless (pb:is-initialized (cl:slot-value self 'alert))
      (cl:return-from pb:is-initialized cl:nil)))
  cl:t)

(cl:defmethod pb:octet-size ((self feed-entity))
  (cl:let ((size 0))
    ;; required string id = 1[json_name = "id"];
    (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
      (cl:incf size 1)
      (cl:incf size (cl:let ((s (pb::%utf8-string-length% (cl:slot-value self 'id))))
        (cl:+ s (varint:length32 s)))))
    ;; optional bool is_deleted = 2 [default = false, json_name = "isDeleted"];
    (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
      (cl:incf size
        (cl:+ 1 1)))
    ;; optional .transit_realtime.TripUpdate trip_update = 3[json_name = "tripUpdate"];
    (cl:when (cl:logbitp 2 (cl:slot-value self '%has-bits%))
      (cl:let ((s (pb:octet-size (cl:slot-value self 'trip-update))))
        (cl:incf size (cl:+ 1 s (varint:length32 s)))))
    ;; optional .transit_realtime.VehiclePosition vehicle = 4[json_name = "vehicle"];
    (cl:when (cl:logbitp 3 (cl:slot-value self '%has-bits%))
      (cl:let ((s (pb:octet-size (cl:slot-value self 'vehicle))))
        (cl:incf size (cl:+ 1 s (varint:length32 s)))))
    ;; optional .transit_realtime.Alert alert = 5[json_name = "alert"];
    (cl:when (cl:logbitp 4 (cl:slot-value self '%has-bits%))
      (cl:let ((s (pb:octet-size (cl:slot-value self 'alert))))
        (cl:incf size (cl:+ 1 s (varint:length32 s)))))
    (cl:setf (cl:slot-value self 'pb::%cached-size%) size)
    size))

(cl:defmethod pb:serialize ((self feed-entity) buffer index limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index index limit)
              (cl:ignorable buffer limit))
  ;; required string id = 1[json_name = "id"];
  (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 10))
    (cl:setf index (wire-format:write-octets-carefully buffer index limit (cl:slot-value (cl:slot-value self 'id) 'pb::%octets%))))
  ;; optional bool is_deleted = 2 [default = false, json_name = "isDeleted"];
  (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 16))
    (cl:setf index (wire-format:write-boolean-carefully buffer index limit (cl:slot-value self 'is-deleted))))
  ;; optional .transit_realtime.TripUpdate trip_update = 3[json_name = "tripUpdate"];
  (cl:when (cl:logbitp 2 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 26))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit (cl:slot-value (cl:slot-value self 'trip-update) 'pb::%cached-size%)))
    (cl:setf index (pb:serialize (cl:slot-value self 'trip-update) buffer index limit)))
  ;; optional .transit_realtime.VehiclePosition vehicle = 4[json_name = "vehicle"];
  (cl:when (cl:logbitp 3 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 34))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit (cl:slot-value (cl:slot-value self 'vehicle) 'pb::%cached-size%)))
    (cl:setf index (pb:serialize (cl:slot-value self 'vehicle) buffer index limit)))
  ;; optional .transit_realtime.Alert alert = 5[json_name = "alert"];
  (cl:when (cl:logbitp 4 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 42))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit (cl:slot-value (cl:slot-value self 'alert) 'pb::%cached-size%)))
    (cl:setf index (pb:serialize (cl:slot-value self 'alert) buffer index limit)))
  ;// Extension range [1000, 2000)
  ;DO_(_extensions_.SerializeWithCachedSizes(
  ;    1000, 2000, *this, output));

  index)

(cl:defmethod pb:merge-from-array ((self feed-entity) buffer start limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index start limit))
  (cl:do ((index start index))
      ((cl:>= index limit) index)
    (cl:declare (cl:type com.google.base:vector-index index))
    (cl:multiple-value-bind (tag new-index)
        (varint:parse-uint32-carefully buffer index limit)
      (cl:setf index new-index)
      (cl:case tag
        ;; required string id = 1[json_name = "id"];
        ((10)
          (cl:multiple-value-bind (value new-index)
              (wire-format:read-octets-carefully buffer index limit)
            (cl:setf (cl:slot-value self 'id) (pb:string-field value))
            (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        ;; optional bool is_deleted = 2 [default = false, json_name = "isDeleted"];
        ((16)
          (cl:multiple-value-bind (value new-index)
              (wire-format:read-boolean-carefully buffer index limit)
            (cl:setf (cl:slot-value self 'is-deleted) value)
            (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        ;; optional .transit_realtime.TripUpdate trip_update = 3[json_name = "tripUpdate"];
        ((26)
          (cl:multiple-value-bind (length new-index)
              (varint:parse-uint31-carefully buffer index limit)
            (cl:when (cl:> (cl:+ new-index length) limit)
              (cl:error "buffer overflow"))
            (cl:let ((message (cl:slot-value self 'trip-update)))
              (cl:when (cl:null message)
                (cl:setf message (cl:make-instance 'transit-realtime::trip-update))
                (cl:setf (cl:slot-value self 'trip-update) message)
                (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 1))
              (cl:setf index (pb:merge-from-array message buffer new-index (cl:+ new-index length)))
              (cl:when (cl:not (cl:= index (cl:+ new-index length)))
                (cl:error "buffer overflow")))))
        ;; optional .transit_realtime.VehiclePosition vehicle = 4[json_name = "vehicle"];
        ((34)
          (cl:multiple-value-bind (length new-index)
              (varint:parse-uint31-carefully buffer index limit)
            (cl:when (cl:> (cl:+ new-index length) limit)
              (cl:error "buffer overflow"))
            (cl:let ((message (cl:slot-value self 'vehicle)))
              (cl:when (cl:null message)
                (cl:setf message (cl:make-instance 'transit-realtime::vehicle-position))
                (cl:setf (cl:slot-value self 'vehicle) message)
                (cl:setf (cl:ldb (cl:byte 1 3) (cl:slot-value self '%has-bits%)) 1))
              (cl:setf index (pb:merge-from-array message buffer new-index (cl:+ new-index length)))
              (cl:when (cl:not (cl:= index (cl:+ new-index length)))
                (cl:error "buffer overflow")))))
        ;; optional .transit_realtime.Alert alert = 5[json_name = "alert"];
        ((42)
          (cl:multiple-value-bind (length new-index)
              (varint:parse-uint31-carefully buffer index limit)
            (cl:when (cl:> (cl:+ new-index length) limit)
              (cl:error "buffer overflow"))
            (cl:let ((message (cl:slot-value self 'alert)))
              (cl:when (cl:null message)
                (cl:setf message (cl:make-instance 'transit-realtime::alert))
                (cl:setf (cl:slot-value self 'alert) message)
                (cl:setf (cl:ldb (cl:byte 1 4) (cl:slot-value self '%has-bits%)) 1))
              (cl:setf index (pb:merge-from-array message buffer new-index (cl:+ new-index length)))
              (cl:when (cl:not (cl:= index (cl:+ new-index length)))
                (cl:error "buffer overflow")))))
        (cl:t
          (cl:when (cl:= (cl:logand tag 7) 4)
            (cl:return-from pb:merge-from-array index))
          (cl:setf index (wire-format:skip-field buffer index limit tag)))))))

(cl:defmethod pb:merge-from-message ((self feed-entity) (from feed-entity))
  (cl:when (cl:logbitp 0 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'id) (cl:slot-value from 'id))
    (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))
  (cl:when (cl:logbitp 1 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'is-deleted) (cl:slot-value from 'is-deleted))
    (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1))
  (cl:when (cl:logbitp 2 (cl:slot-value from '%has-bits%))
    (cl:let ((message (cl:slot-value self 'trip-update)))
      (cl:when (cl:null message)
        (cl:setf message (cl:make-instance 'transit-realtime::trip-update))
        (cl:setf (cl:slot-value self 'trip-update) message)
        (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 1))
     (pb:merge-from-message message (cl:slot-value from 'trip-update))))
  (cl:when (cl:logbitp 3 (cl:slot-value from '%has-bits%))
    (cl:let ((message (cl:slot-value self 'vehicle)))
      (cl:when (cl:null message)
        (cl:setf message (cl:make-instance 'transit-realtime::vehicle-position))
        (cl:setf (cl:slot-value self 'vehicle) message)
        (cl:setf (cl:ldb (cl:byte 1 3) (cl:slot-value self '%has-bits%)) 1))
     (pb:merge-from-message message (cl:slot-value from 'vehicle))))
  (cl:when (cl:logbitp 4 (cl:slot-value from '%has-bits%))
    (cl:let ((message (cl:slot-value self 'alert)))
      (cl:when (cl:null message)
        (cl:setf message (cl:make-instance 'transit-realtime::alert))
        (cl:setf (cl:slot-value self 'alert) message)
        (cl:setf (cl:ldb (cl:byte 1 4) (cl:slot-value self '%has-bits%)) 1))
     (pb:merge-from-message message (cl:slot-value from 'alert))))
)


(cl:defclass trip-update-stop-time-event (pb:protocol-buffer)
  (
  (delay
   :accessor delay
   :initform 0
   :type (cl:signed-byte 32))
  (time
   :accessor time
   :initform 0
   :type (cl:signed-byte 64))
  (uncertainty
   :accessor uncertainty
   :initform 0
   :type (cl:signed-byte 32))
  (%has-bits%
   :accessor %has-bits%
   :initform 0
   :type (cl:unsigned-byte 3))
  (pb::%cached-size%
   :initform 0
   :type (cl:integer 0 #.(cl:1- cl:array-dimension-limit)))
  ))

(cl:export 'trip-update-stop-time-event)

(cl:export 'delay)


(cl:defmethod (cl:setf delay) :after (x (self trip-update-stop-time-event))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-delay)
  (cl:defgeneric has-delay (proto)))
(cl:defmethod has-delay ((self trip-update-stop-time-event))
  (cl:logbitp 0 (cl:slot-value self '%has-bits%)))
(cl:export 'has-delay)

(cl:unless (cl:fboundp 'clear-delay)
  (cl:defgeneric clear-delay (proto)))
(cl:defmethod clear-delay ((self trip-update-stop-time-event))
  (cl:setf (cl:slot-value self 'delay) 0)
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-delay)

(cl:export 'time)


(cl:defmethod (cl:setf time) :after (x (self trip-update-stop-time-event))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-time)
  (cl:defgeneric has-time (proto)))
(cl:defmethod has-time ((self trip-update-stop-time-event))
  (cl:logbitp 1 (cl:slot-value self '%has-bits%)))
(cl:export 'has-time)

(cl:unless (cl:fboundp 'clear-time)
  (cl:defgeneric clear-time (proto)))
(cl:defmethod clear-time ((self trip-update-stop-time-event))
  (cl:setf (cl:slot-value self 'time) 0)
  (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-time)

(cl:export 'uncertainty)


(cl:defmethod (cl:setf uncertainty) :after (x (self trip-update-stop-time-event))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-uncertainty)
  (cl:defgeneric has-uncertainty (proto)))
(cl:defmethod has-uncertainty ((self trip-update-stop-time-event))
  (cl:logbitp 2 (cl:slot-value self '%has-bits%)))
(cl:export 'has-uncertainty)

(cl:unless (cl:fboundp 'clear-uncertainty)
  (cl:defgeneric clear-uncertainty (proto)))
(cl:defmethod clear-uncertainty ((self trip-update-stop-time-event))
  (cl:setf (cl:slot-value self 'uncertainty) 0)
  (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-uncertainty)



(cl:defclass trip-update-stop-time-update (pb:protocol-buffer)
  (
  (stop-sequence
   :accessor stop-sequence
   :initform 0
   :type (cl:unsigned-byte 32))
  (stop-id
   :accessor stop-id
   :initform (pb:string-field "")
   :type pb::%sf%)
  (arrival
   :accessor arrival
   :initform cl:nil
   :type (cl:or cl:null transit-realtime::trip-update-stop-time-event))
  (departure
   :accessor departure
   :initform cl:nil
   :type (cl:or cl:null transit-realtime::trip-update-stop-time-event))
  (schedule-relationship
   :accessor schedule-relationship
   :initform transit-realtime::+trip-update-stop-time-update-schedule-relationship-scheduled+
   :type transit-realtime::trip-update-stop-time-update-schedule-relationship)
  (%has-bits%
   :accessor %has-bits%
   :initform 0
   :type (cl:unsigned-byte 5))
  (pb::%cached-size%
   :initform 0
   :type (cl:integer 0 #.(cl:1- cl:array-dimension-limit)))
  ))

(cl:export 'trip-update-stop-time-update)

(cl:export 'stop-sequence)


(cl:defmethod (cl:setf stop-sequence) :after (x (self trip-update-stop-time-update))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-stop-sequence)
  (cl:defgeneric has-stop-sequence (proto)))
(cl:defmethod has-stop-sequence ((self trip-update-stop-time-update))
  (cl:logbitp 0 (cl:slot-value self '%has-bits%)))
(cl:export 'has-stop-sequence)

(cl:unless (cl:fboundp 'clear-stop-sequence)
  (cl:defgeneric clear-stop-sequence (proto)))
(cl:defmethod clear-stop-sequence ((self trip-update-stop-time-update))
  (cl:setf (cl:slot-value self 'stop-sequence) 0)
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-stop-sequence)

(cl:export 'stop-id)


(cl:defmethod (cl:setf stop-id) :after (x (self trip-update-stop-time-update))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-stop-id)
  (cl:defgeneric has-stop-id (proto)))
(cl:defmethod has-stop-id ((self trip-update-stop-time-update))
  (cl:logbitp 1 (cl:slot-value self '%has-bits%)))
(cl:export 'has-stop-id)

(cl:unless (cl:fboundp 'clear-stop-id)
  (cl:defgeneric clear-stop-id (proto)))
(cl:defmethod clear-stop-id ((self trip-update-stop-time-update))
  (cl:setf (cl:slot-value self 'stop-id) (pb:string-field ""))
  (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-stop-id)

(cl:export 'arrival)


(cl:defmethod (cl:setf arrival) :after (x (self trip-update-stop-time-update))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-arrival)
  (cl:defgeneric has-arrival (proto)))
(cl:defmethod has-arrival ((self trip-update-stop-time-update))
  (cl:logbitp 2 (cl:slot-value self '%has-bits%)))
(cl:export 'has-arrival)

(cl:unless (cl:fboundp 'clear-arrival)
  (cl:defgeneric clear-arrival (proto)))
(cl:defmethod clear-arrival ((self trip-update-stop-time-update))
  (cl:setf (cl:slot-value self 'arrival) cl:nil)
  (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-arrival)

(cl:export 'departure)


(cl:defmethod (cl:setf departure) :after (x (self trip-update-stop-time-update))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 3) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-departure)
  (cl:defgeneric has-departure (proto)))
(cl:defmethod has-departure ((self trip-update-stop-time-update))
  (cl:logbitp 3 (cl:slot-value self '%has-bits%)))
(cl:export 'has-departure)

(cl:unless (cl:fboundp 'clear-departure)
  (cl:defgeneric clear-departure (proto)))
(cl:defmethod clear-departure ((self trip-update-stop-time-update))
  (cl:setf (cl:slot-value self 'departure) cl:nil)
  (cl:setf (cl:ldb (cl:byte 1 3) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-departure)

(cl:export 'schedule-relationship)


(cl:defmethod (cl:setf schedule-relationship) :after (x (self trip-update-stop-time-update))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 4) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-schedule-relationship)
  (cl:defgeneric has-schedule-relationship (proto)))
(cl:defmethod has-schedule-relationship ((self trip-update-stop-time-update))
  (cl:logbitp 4 (cl:slot-value self '%has-bits%)))
(cl:export 'has-schedule-relationship)

(cl:unless (cl:fboundp 'clear-schedule-relationship)
  (cl:defgeneric clear-schedule-relationship (proto)))
(cl:defmethod clear-schedule-relationship ((self trip-update-stop-time-update))
  (cl:setf (cl:slot-value self 'schedule-relationship) transit-realtime::+trip-update-stop-time-update-schedule-relationship-scheduled+)
  (cl:setf (cl:ldb (cl:byte 1 4) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-schedule-relationship)



(cl:defclass trip-update (pb:protocol-buffer)
  (
  (trip
   :accessor trip
   :initform cl:nil
   :type (cl:or cl:null transit-realtime::trip-descriptor))
  (vehicle
   :accessor vehicle
   :initform cl:nil
   :type (cl:or cl:null transit-realtime::vehicle-descriptor))
  (stop-time-update
   :accessor stop-time-update
   :initform (cl:make-array
              0
              :element-type 'transit-realtime::trip-update-stop-time-update
              :fill-pointer 0 :adjustable cl:t)
   :type (cl:vector transit-realtime::trip-update-stop-time-update))
  (timestamp
   :accessor timestamp
   :initform 0
   :type (cl:unsigned-byte 64))
  (delay
   :accessor delay
   :initform 0
   :type (cl:signed-byte 32))
  (%has-bits%
   :accessor %has-bits%
   :initform 0
   :type (cl:unsigned-byte 5))
  (pb::%cached-size%
   :initform 0
   :type (cl:integer 0 #.(cl:1- cl:array-dimension-limit)))
  ))

(cl:export 'trip-update)

(cl:export 'trip)


(cl:defmethod (cl:setf trip) :after (x (self trip-update))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-trip)
  (cl:defgeneric has-trip (proto)))
(cl:defmethod has-trip ((self trip-update))
  (cl:logbitp 0 (cl:slot-value self '%has-bits%)))
(cl:export 'has-trip)

(cl:unless (cl:fboundp 'clear-trip)
  (cl:defgeneric clear-trip (proto)))
(cl:defmethod clear-trip ((self trip-update))
  (cl:setf (cl:slot-value self 'trip) cl:nil)
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-trip)

(cl:export 'vehicle)


(cl:defmethod (cl:setf vehicle) :after (x (self trip-update))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-vehicle)
  (cl:defgeneric has-vehicle (proto)))
(cl:defmethod has-vehicle ((self trip-update))
  (cl:logbitp 1 (cl:slot-value self '%has-bits%)))
(cl:export 'has-vehicle)

(cl:unless (cl:fboundp 'clear-vehicle)
  (cl:defgeneric clear-vehicle (proto)))
(cl:defmethod clear-vehicle ((self trip-update))
  (cl:setf (cl:slot-value self 'vehicle) cl:nil)
  (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-vehicle)

(cl:export 'stop-time-update)

(cl:unless (cl:fboundp 'clear-stop-time-update)
  (cl:defgeneric clear-stop-time-update (proto)))
(cl:defmethod clear-stop-time-update ((self trip-update))
  (cl:setf (cl:slot-value self 'stop-time-update)
           (cl:make-array 0 :element-type 'transit-realtime::trip-update-stop-time-update
            :fill-pointer 0 :adjustable cl:t))
  (cl:values))
(cl:export 'clear-stop-time-update)

(cl:export 'timestamp)


(cl:defmethod (cl:setf timestamp) :after (x (self trip-update))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 3) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-timestamp)
  (cl:defgeneric has-timestamp (proto)))
(cl:defmethod has-timestamp ((self trip-update))
  (cl:logbitp 3 (cl:slot-value self '%has-bits%)))
(cl:export 'has-timestamp)

(cl:unless (cl:fboundp 'clear-timestamp)
  (cl:defgeneric clear-timestamp (proto)))
(cl:defmethod clear-timestamp ((self trip-update))
  (cl:setf (cl:slot-value self 'timestamp) 0)
  (cl:setf (cl:ldb (cl:byte 1 3) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-timestamp)

(cl:export 'delay)


(cl:defmethod (cl:setf delay) :after (x (self trip-update))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 4) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-delay)
  (cl:defgeneric has-delay (proto)))
(cl:defmethod has-delay ((self trip-update))
  (cl:logbitp 4 (cl:slot-value self '%has-bits%)))
(cl:export 'has-delay)

(cl:unless (cl:fboundp 'clear-delay)
  (cl:defgeneric clear-delay (proto)))
(cl:defmethod clear-delay ((self trip-update))
  (cl:setf (cl:slot-value self 'delay) 0)
  (cl:setf (cl:ldb (cl:byte 1 4) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-delay)


(cl:defmethod cl:print-object ((self trip-update-stop-time-event) stream)
  (cl:pprint-logical-block (stream cl:nil)
    (cl:print-unreadable-object (self stream :type cl:t :identity cl:t)
      (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_delay: ~s" (delay self)))
      (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_time: ~s" (time self)))
      (cl:when (cl:logbitp 2 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_uncertainty: ~s" (uncertainty self)))
      ))
  (cl:values))

(cl:defmethod pb:clear ((self trip-update-stop-time-event))
  (cl:setf (cl:slot-value self 'delay) 0)
  (cl:setf (cl:slot-value self 'time) 0)
  (cl:setf (cl:slot-value self 'uncertainty) 0)
  (cl:setf (cl:slot-value self '%has-bits%) 0)
  (cl:values))

(cl:defmethod pb:is-initialized ((self trip-update-stop-time-event))
  cl:t)

(cl:defmethod pb:octet-size ((self trip-update-stop-time-event))
  (cl:let ((size 0))
    ;; optional int32 delay = 1[json_name = "delay"];
    (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
      (cl:incf size
        (cl:+ 1 (varint:length64 (cl:ldb (cl:byte 64 0) (cl:slot-value self 'delay))))))
    ;; optional int64 time = 2[json_name = "time"];
    (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
      (cl:incf size
        (cl:+ 1 (varint:length64 (cl:ldb (cl:byte 64 0) (cl:slot-value self 'time))))))
    ;; optional int32 uncertainty = 3[json_name = "uncertainty"];
    (cl:when (cl:logbitp 2 (cl:slot-value self '%has-bits%))
      (cl:incf size
        (cl:+ 1 (varint:length64 (cl:ldb (cl:byte 64 0) (cl:slot-value self 'uncertainty))))))
    (cl:setf (cl:slot-value self 'pb::%cached-size%) size)
    size))

(cl:defmethod pb:serialize ((self trip-update-stop-time-event) buffer index limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index index limit)
              (cl:ignorable buffer limit))
  ;; optional int32 delay = 1[json_name = "delay"];
  (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 8))
    (cl:setf index (varint:encode-uint64-carefully buffer index limit (cl:ldb (cl:byte 64 0) (cl:slot-value self 'delay)))))
  ;; optional int64 time = 2[json_name = "time"];
  (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 16))
    (cl:setf index (varint:encode-uint64-carefully buffer index limit (cl:ldb (cl:byte 64 0) (cl:slot-value self 'time)))))
  ;; optional int32 uncertainty = 3[json_name = "uncertainty"];
  (cl:when (cl:logbitp 2 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 24))
    (cl:setf index (varint:encode-uint64-carefully buffer index limit (cl:ldb (cl:byte 64 0) (cl:slot-value self 'uncertainty)))))
  ;// Extension range [1000, 2000)
  ;DO_(_extensions_.SerializeWithCachedSizes(
  ;    1000, 2000, *this, output));

  index)

(cl:defmethod pb:merge-from-array ((self trip-update-stop-time-event) buffer start limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index start limit))
  (cl:do ((index start index))
      ((cl:>= index limit) index)
    (cl:declare (cl:type com.google.base:vector-index index))
    (cl:multiple-value-bind (tag new-index)
        (varint:parse-uint32-carefully buffer index limit)
      (cl:setf index new-index)
      (cl:case tag
        ;; optional int32 delay = 1[json_name = "delay"];
        ((8)
          (cl:multiple-value-bind (value new-index)
              (varint:parse-int32-carefully buffer index limit)
            (cl:setf (cl:slot-value self 'delay) value)
            (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        ;; optional int64 time = 2[json_name = "time"];
        ((16)
          (cl:multiple-value-bind (value new-index)
              (varint:parse-int64-carefully buffer index limit)
            (cl:setf (cl:slot-value self 'time) value)
            (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        ;; optional int32 uncertainty = 3[json_name = "uncertainty"];
        ((24)
          (cl:multiple-value-bind (value new-index)
              (varint:parse-int32-carefully buffer index limit)
            (cl:setf (cl:slot-value self 'uncertainty) value)
            (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        (cl:t
          (cl:when (cl:= (cl:logand tag 7) 4)
            (cl:return-from pb:merge-from-array index))
          (cl:setf index (wire-format:skip-field buffer index limit tag)))))))

(cl:defmethod pb:merge-from-message ((self trip-update-stop-time-event) (from trip-update-stop-time-event))
  (cl:when (cl:logbitp 0 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'delay) (cl:slot-value from 'delay))
    (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))
  (cl:when (cl:logbitp 1 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'time) (cl:slot-value from 'time))
    (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1))
  (cl:when (cl:logbitp 2 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'uncertainty) (cl:slot-value from 'uncertainty))
    (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 1))
)



(cl:defmethod cl:print-object ((self trip-update-stop-time-update) stream)
  (cl:pprint-logical-block (stream cl:nil)
    (cl:print-unreadable-object (self stream :type cl:t :identity cl:t)
      (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_stop-sequence: ~s" (stop-sequence self)))
      (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_stop-id: ~s" (stop-id self)))
      (cl:when (cl:logbitp 2 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_arrival: ~s" (arrival self)))
      (cl:when (cl:logbitp 3 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_departure: ~s" (departure self)))
      (cl:when (cl:logbitp 4 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_schedule-relationship: ~s" (schedule-relationship self)))
      ))
  (cl:values))

(cl:defmethod pb:clear ((self trip-update-stop-time-update))
  (cl:setf (cl:slot-value self 'stop-sequence) 0)
  (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'stop-id) (pb:string-field "")))
  (cl:when (cl:logbitp 2 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'arrival) cl:nil))
  (cl:when (cl:logbitp 3 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'departure) cl:nil))
  (cl:setf (cl:slot-value self 'schedule-relationship) transit-realtime::+trip-update-stop-time-update-schedule-relationship-scheduled+)
  (cl:setf (cl:slot-value self '%has-bits%) 0)
  (cl:values))

(cl:defmethod pb:is-initialized ((self trip-update-stop-time-update))
  (cl:when (cl:logbitp 2 (cl:slot-value self '%has-bits%))
    (cl:unless (pb:is-initialized (cl:slot-value self 'arrival))
      (cl:return-from pb:is-initialized cl:nil)))
  (cl:when (cl:logbitp 3 (cl:slot-value self '%has-bits%))
    (cl:unless (pb:is-initialized (cl:slot-value self 'departure))
      (cl:return-from pb:is-initialized cl:nil)))
  cl:t)

(cl:defmethod pb:octet-size ((self trip-update-stop-time-update))
  (cl:let ((size 0))
    ;; optional uint32 stop_sequence = 1[json_name = "stopSequence"];
    (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
      (cl:incf size
        (cl:+ 1 (varint:length32 (cl:slot-value self 'stop-sequence)))))
    ;; optional string stop_id = 4[json_name = "stopId"];
    (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
      (cl:incf size 1)
      (cl:incf size (cl:let ((s (pb::%utf8-string-length% (cl:slot-value self 'stop-id))))
        (cl:+ s (varint:length32 s)))))
    ;; optional .transit_realtime.TripUpdate.StopTimeEvent arrival = 2[json_name = "arrival"];
    (cl:when (cl:logbitp 2 (cl:slot-value self '%has-bits%))
      (cl:let ((s (pb:octet-size (cl:slot-value self 'arrival))))
        (cl:incf size (cl:+ 1 s (varint:length32 s)))))
    ;; optional .transit_realtime.TripUpdate.StopTimeEvent departure = 3[json_name = "departure"];
    (cl:when (cl:logbitp 3 (cl:slot-value self '%has-bits%))
      (cl:let ((s (pb:octet-size (cl:slot-value self 'departure))))
        (cl:incf size (cl:+ 1 s (varint:length32 s)))))
    ;; optional .transit_realtime.TripUpdate.StopTimeUpdate.ScheduleRelationship schedule_relationship = 5 [default = SCHEDULED, json_name = "scheduleRelationship"];
    (cl:when (cl:logbitp 4 (cl:slot-value self '%has-bits%))
      (cl:incf size 1)
      (cl:incf size (varint:length64 (cl:ldb (cl:byte 64 0) (cl:slot-value self 'schedule-relationship)))))
    (cl:setf (cl:slot-value self 'pb::%cached-size%) size)
    size))

(cl:defmethod pb:serialize ((self trip-update-stop-time-update) buffer index limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index index limit)
              (cl:ignorable buffer limit))
  ;; optional uint32 stop_sequence = 1[json_name = "stopSequence"];
  (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 8))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit (cl:slot-value self 'stop-sequence))))
  ;; optional .transit_realtime.TripUpdate.StopTimeEvent arrival = 2[json_name = "arrival"];
  (cl:when (cl:logbitp 2 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 18))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit (cl:slot-value (cl:slot-value self 'arrival) 'pb::%cached-size%)))
    (cl:setf index (pb:serialize (cl:slot-value self 'arrival) buffer index limit)))
  ;; optional .transit_realtime.TripUpdate.StopTimeEvent departure = 3[json_name = "departure"];
  (cl:when (cl:logbitp 3 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 26))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit (cl:slot-value (cl:slot-value self 'departure) 'pb::%cached-size%)))
    (cl:setf index (pb:serialize (cl:slot-value self 'departure) buffer index limit)))
  ;; optional string stop_id = 4[json_name = "stopId"];
  (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 34))
    (cl:setf index (wire-format:write-octets-carefully buffer index limit (cl:slot-value (cl:slot-value self 'stop-id) 'pb::%octets%))))
  ;; optional .transit_realtime.TripUpdate.StopTimeUpdate.ScheduleRelationship schedule_relationship = 5 [default = SCHEDULED, json_name = "scheduleRelationship"];
  (cl:when (cl:logbitp 4 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 40))
    (cl:setf index
     (varint:encode-uint64-carefully buffer index limit
      (cl:ldb (cl:byte 64 0) (cl:slot-value self 'schedule-relationship)))))
  ;// Extension range [1000, 2000)
  ;DO_(_extensions_.SerializeWithCachedSizes(
  ;    1000, 2000, *this, output));

  index)

(cl:defmethod pb:merge-from-array ((self trip-update-stop-time-update) buffer start limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index start limit))
  (cl:do ((index start index))
      ((cl:>= index limit) index)
    (cl:declare (cl:type com.google.base:vector-index index))
    (cl:multiple-value-bind (tag new-index)
        (varint:parse-uint32-carefully buffer index limit)
      (cl:setf index new-index)
      (cl:case tag
        ;; optional uint32 stop_sequence = 1[json_name = "stopSequence"];
        ((8)
          (cl:multiple-value-bind (value new-index)
              (varint:parse-uint32-carefully buffer index limit)
            (cl:setf (cl:slot-value self 'stop-sequence) value)
            (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        ;; optional .transit_realtime.TripUpdate.StopTimeEvent arrival = 2[json_name = "arrival"];
        ((18)
          (cl:multiple-value-bind (length new-index)
              (varint:parse-uint31-carefully buffer index limit)
            (cl:when (cl:> (cl:+ new-index length) limit)
              (cl:error "buffer overflow"))
            (cl:let ((message (cl:slot-value self 'arrival)))
              (cl:when (cl:null message)
                (cl:setf message (cl:make-instance 'transit-realtime::trip-update-stop-time-event))
                (cl:setf (cl:slot-value self 'arrival) message)
                (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 1))
              (cl:setf index (pb:merge-from-array message buffer new-index (cl:+ new-index length)))
              (cl:when (cl:not (cl:= index (cl:+ new-index length)))
                (cl:error "buffer overflow")))))
        ;; optional .transit_realtime.TripUpdate.StopTimeEvent departure = 3[json_name = "departure"];
        ((26)
          (cl:multiple-value-bind (length new-index)
              (varint:parse-uint31-carefully buffer index limit)
            (cl:when (cl:> (cl:+ new-index length) limit)
              (cl:error "buffer overflow"))
            (cl:let ((message (cl:slot-value self 'departure)))
              (cl:when (cl:null message)
                (cl:setf message (cl:make-instance 'transit-realtime::trip-update-stop-time-event))
                (cl:setf (cl:slot-value self 'departure) message)
                (cl:setf (cl:ldb (cl:byte 1 3) (cl:slot-value self '%has-bits%)) 1))
              (cl:setf index (pb:merge-from-array message buffer new-index (cl:+ new-index length)))
              (cl:when (cl:not (cl:= index (cl:+ new-index length)))
                (cl:error "buffer overflow")))))
        ;; optional string stop_id = 4[json_name = "stopId"];
        ((34)
          (cl:multiple-value-bind (value new-index)
              (wire-format:read-octets-carefully buffer index limit)
            (cl:setf (cl:slot-value self 'stop-id) (pb:string-field value))
            (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        ;; optional .transit_realtime.TripUpdate.StopTimeUpdate.ScheduleRelationship schedule_relationship = 5 [default = SCHEDULED, json_name = "scheduleRelationship"];
        ((40)
          (cl:multiple-value-bind (value new-index)
              (varint:parse-int32-carefully buffer index limit)
            ;; XXXXX: when valid, set field, else add to unknown fields
            (cl:setf (cl:slot-value self 'schedule-relationship) value)
            (cl:setf (cl:ldb (cl:byte 1 4) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        (cl:t
          (cl:when (cl:= (cl:logand tag 7) 4)
            (cl:return-from pb:merge-from-array index))
          (cl:setf index (wire-format:skip-field buffer index limit tag)))))))

(cl:defmethod pb:merge-from-message ((self trip-update-stop-time-update) (from trip-update-stop-time-update))
  (cl:when (cl:logbitp 0 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'stop-sequence) (cl:slot-value from 'stop-sequence))
    (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))
  (cl:when (cl:logbitp 1 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'stop-id) (cl:slot-value from 'stop-id))
    (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1))
  (cl:when (cl:logbitp 2 (cl:slot-value from '%has-bits%))
    (cl:let ((message (cl:slot-value self 'arrival)))
      (cl:when (cl:null message)
        (cl:setf message (cl:make-instance 'transit-realtime::trip-update-stop-time-event))
        (cl:setf (cl:slot-value self 'arrival) message)
        (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 1))
     (pb:merge-from-message message (cl:slot-value from 'arrival))))
  (cl:when (cl:logbitp 3 (cl:slot-value from '%has-bits%))
    (cl:let ((message (cl:slot-value self 'departure)))
      (cl:when (cl:null message)
        (cl:setf message (cl:make-instance 'transit-realtime::trip-update-stop-time-event))
        (cl:setf (cl:slot-value self 'departure) message)
        (cl:setf (cl:ldb (cl:byte 1 3) (cl:slot-value self '%has-bits%)) 1))
     (pb:merge-from-message message (cl:slot-value from 'departure))))
  (cl:when (cl:logbitp 4 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'schedule-relationship) (cl:slot-value from 'schedule-relationship))
    (cl:setf (cl:ldb (cl:byte 1 4) (cl:slot-value self '%has-bits%)) 1))
)



(cl:defmethod cl:print-object ((self trip-update) stream)
  (cl:pprint-logical-block (stream cl:nil)
    (cl:print-unreadable-object (self stream :type cl:t :identity cl:t)
      (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_trip: ~s" (trip self)))
      (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_vehicle: ~s" (vehicle self)))
      (cl:format stream " ~_stop-time-update: ~s" (stop-time-update self))
      (cl:when (cl:logbitp 3 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_timestamp: ~s" (timestamp self)))
      (cl:when (cl:logbitp 4 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_delay: ~s" (delay self)))
      ))
  (cl:values))

(cl:defmethod pb:clear ((self trip-update))
  (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'trip) cl:nil))
  (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'vehicle) cl:nil))
  (cl:setf (cl:slot-value self 'timestamp) 0)
  (cl:setf (cl:slot-value self 'delay) 0)
  (cl:setf (cl:slot-value self 'stop-time-update)
           (cl:make-array 0 :element-type 'transit-realtime::trip-update-stop-time-update
            :fill-pointer 0 :adjustable cl:t))
  (cl:setf (cl:slot-value self '%has-bits%) 0)
  (cl:values))

(cl:defmethod pb:is-initialized ((self trip-update))
  (cl:when (cl:/= (cl:logand (cl:slot-value self '%has-bits%)
                             #b00001)
                  #b00001)
    (cl:return-from pb:is-initialized cl:nil))
  (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
    (cl:unless (pb:is-initialized (cl:slot-value self 'trip))
      (cl:return-from pb:is-initialized cl:nil)))
  (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
    (cl:unless (pb:is-initialized (cl:slot-value self 'vehicle))
      (cl:return-from pb:is-initialized cl:nil)))
  (cl:let* ((x (cl:slot-value self 'stop-time-update))
            (length (cl:length x)))
    (cl:dotimes (i length)
      (cl:unless (pb:is-initialized (cl:aref x i))
        (cl:return-from pb:is-initialized cl:nil))))
  cl:t)

(cl:defmethod pb:octet-size ((self trip-update))
  (cl:let ((size 0))
    ;; required .transit_realtime.TripDescriptor trip = 1[json_name = "trip"];
    (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
      (cl:let ((s (pb:octet-size (cl:slot-value self 'trip))))
        (cl:incf size (cl:+ 1 s (varint:length32 s)))))
    ;; optional .transit_realtime.VehicleDescriptor vehicle = 3[json_name = "vehicle"];
    (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
      (cl:let ((s (pb:octet-size (cl:slot-value self 'vehicle))))
        (cl:incf size (cl:+ 1 s (varint:length32 s)))))
    ;; optional uint64 timestamp = 4[json_name = "timestamp"];
    (cl:when (cl:logbitp 3 (cl:slot-value self '%has-bits%))
      (cl:incf size
        (cl:+ 1 (varint:length64 (cl:slot-value self 'timestamp)))))
    ;; optional int32 delay = 5[json_name = "delay"];
    (cl:when (cl:logbitp 4 (cl:slot-value self '%has-bits%))
      (cl:incf size
        (cl:+ 1 (varint:length64 (cl:ldb (cl:byte 64 0) (cl:slot-value self 'delay))))))
    ;; repeated .transit_realtime.TripUpdate.StopTimeUpdate stop_time_update = 2[json_name = "stopTimeUpdate"];
    (cl:let* ((v (cl:slot-value self 'stop-time-update))
              (length (cl:length v)))
      (cl:incf size (cl:* 1 length))
      (cl:dotimes (i length)
        (cl:let ((s (pb:octet-size (cl:aref v i))))
          (cl:incf size (cl:+ s (varint:length32 s))))))
    (cl:setf (cl:slot-value self 'pb::%cached-size%) size)
    size))

(cl:defmethod pb:serialize ((self trip-update) buffer index limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index index limit)
              (cl:ignorable buffer limit))
  ;; required .transit_realtime.TripDescriptor trip = 1[json_name = "trip"];
  (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 10))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit (cl:slot-value (cl:slot-value self 'trip) 'pb::%cached-size%)))
    (cl:setf index (pb:serialize (cl:slot-value self 'trip) buffer index limit)))
  ;; repeated .transit_realtime.TripUpdate.StopTimeUpdate stop_time_update = 2[json_name = "stopTimeUpdate"];
  (cl:let* ((v (cl:slot-value self 'stop-time-update))
            (length (cl:length v)))
    (cl:loop for i from 0 below length do
       (cl:setf index (varint:encode-uint32-carefully buffer index limit 18))
       (cl:setf index (varint:encode-uint32-carefully buffer index limit (cl:slot-value (cl:aref v i) 'pb::%cached-size%)))
       (cl:setf index (pb:serialize (cl:aref v i) buffer index limit))))
  ;; optional .transit_realtime.VehicleDescriptor vehicle = 3[json_name = "vehicle"];
  (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 26))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit (cl:slot-value (cl:slot-value self 'vehicle) 'pb::%cached-size%)))
    (cl:setf index (pb:serialize (cl:slot-value self 'vehicle) buffer index limit)))
  ;; optional uint64 timestamp = 4[json_name = "timestamp"];
  (cl:when (cl:logbitp 3 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 32))
    (cl:setf index (varint:encode-uint64-carefully buffer index limit (cl:slot-value self 'timestamp))))
  ;; optional int32 delay = 5[json_name = "delay"];
  (cl:when (cl:logbitp 4 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 40))
    (cl:setf index (varint:encode-uint64-carefully buffer index limit (cl:ldb (cl:byte 64 0) (cl:slot-value self 'delay)))))
  ;// Extension range [1000, 2000)
  ;DO_(_extensions_.SerializeWithCachedSizes(
  ;    1000, 2000, *this, output));

  index)

(cl:defmethod pb:merge-from-array ((self trip-update) buffer start limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index start limit))
  (cl:do ((index start index))
      ((cl:>= index limit) index)
    (cl:declare (cl:type com.google.base:vector-index index))
    (cl:multiple-value-bind (tag new-index)
        (varint:parse-uint32-carefully buffer index limit)
      (cl:setf index new-index)
      (cl:case tag
        ;; required .transit_realtime.TripDescriptor trip = 1[json_name = "trip"];
        ((10)
          (cl:multiple-value-bind (length new-index)
              (varint:parse-uint31-carefully buffer index limit)
            (cl:when (cl:> (cl:+ new-index length) limit)
              (cl:error "buffer overflow"))
            (cl:let ((message (cl:slot-value self 'trip)))
              (cl:when (cl:null message)
                (cl:setf message (cl:make-instance 'transit-realtime::trip-descriptor))
                (cl:setf (cl:slot-value self 'trip) message)
                (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))
              (cl:setf index (pb:merge-from-array message buffer new-index (cl:+ new-index length)))
              (cl:when (cl:not (cl:= index (cl:+ new-index length)))
                (cl:error "buffer overflow")))))
        ;; repeated .transit_realtime.TripUpdate.StopTimeUpdate stop_time_update = 2[json_name = "stopTimeUpdate"];
        ((18)
          (cl:multiple-value-bind (length new-index)
              (varint:parse-uint31-carefully buffer index limit)
            (cl:when (cl:> (cl:+ new-index length) limit)
              (cl:error "buffer overflow"))
            (cl:let ((message (cl:make-instance 'transit-realtime::trip-update-stop-time-update)))
              (cl:setf index (pb:merge-from-array message buffer new-index (cl:+ new-index length)))
              (cl:when (cl:not (cl:= index (cl:+ new-index length)))
                (cl:error "buffer overflow"))
              (cl:vector-push-extend message (cl:slot-value self 'stop-time-update)))))
        ;; optional .transit_realtime.VehicleDescriptor vehicle = 3[json_name = "vehicle"];
        ((26)
          (cl:multiple-value-bind (length new-index)
              (varint:parse-uint31-carefully buffer index limit)
            (cl:when (cl:> (cl:+ new-index length) limit)
              (cl:error "buffer overflow"))
            (cl:let ((message (cl:slot-value self 'vehicle)))
              (cl:when (cl:null message)
                (cl:setf message (cl:make-instance 'transit-realtime::vehicle-descriptor))
                (cl:setf (cl:slot-value self 'vehicle) message)
                (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1))
              (cl:setf index (pb:merge-from-array message buffer new-index (cl:+ new-index length)))
              (cl:when (cl:not (cl:= index (cl:+ new-index length)))
                (cl:error "buffer overflow")))))
        ;; optional uint64 timestamp = 4[json_name = "timestamp"];
        ((32)
          (cl:multiple-value-bind (value new-index)
              (varint:parse-uint64-carefully buffer index limit)
            (cl:setf (cl:slot-value self 'timestamp) value)
            (cl:setf (cl:ldb (cl:byte 1 3) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        ;; optional int32 delay = 5[json_name = "delay"];
        ((40)
          (cl:multiple-value-bind (value new-index)
              (varint:parse-int32-carefully buffer index limit)
            (cl:setf (cl:slot-value self 'delay) value)
            (cl:setf (cl:ldb (cl:byte 1 4) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        (cl:t
          (cl:when (cl:= (cl:logand tag 7) 4)
            (cl:return-from pb:merge-from-array index))
          (cl:setf index (wire-format:skip-field buffer index limit tag)))))))

(cl:defmethod pb:merge-from-message ((self trip-update) (from trip-update))
  (cl:let* ((v (cl:slot-value self 'stop-time-update))
            (vf (cl:slot-value from 'stop-time-update))
            (length (cl:length vf)))
    (cl:loop for i from 0 below length do
      (cl:vector-push-extend (cl:aref vf i) v)))
  (cl:when (cl:logbitp 0 (cl:slot-value from '%has-bits%))
    (cl:let ((message (cl:slot-value self 'trip)))
      (cl:when (cl:null message)
        (cl:setf message (cl:make-instance 'transit-realtime::trip-descriptor))
        (cl:setf (cl:slot-value self 'trip) message)
        (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))
     (pb:merge-from-message message (cl:slot-value from 'trip))))
  (cl:when (cl:logbitp 1 (cl:slot-value from '%has-bits%))
    (cl:let ((message (cl:slot-value self 'vehicle)))
      (cl:when (cl:null message)
        (cl:setf message (cl:make-instance 'transit-realtime::vehicle-descriptor))
        (cl:setf (cl:slot-value self 'vehicle) message)
        (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1))
     (pb:merge-from-message message (cl:slot-value from 'vehicle))))
  (cl:when (cl:logbitp 3 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'timestamp) (cl:slot-value from 'timestamp))
    (cl:setf (cl:ldb (cl:byte 1 3) (cl:slot-value self '%has-bits%)) 1))
  (cl:when (cl:logbitp 4 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'delay) (cl:slot-value from 'delay))
    (cl:setf (cl:ldb (cl:byte 1 4) (cl:slot-value self '%has-bits%)) 1))
)


(cl:defclass vehicle-position (pb:protocol-buffer)
  (
  (trip
   :accessor trip
   :initform cl:nil
   :type (cl:or cl:null transit-realtime::trip-descriptor))
  (vehicle
   :accessor vehicle
   :initform cl:nil
   :type (cl:or cl:null transit-realtime::vehicle-descriptor))
  (position
   :accessor position
   :initform cl:nil
   :type (cl:or cl:null transit-realtime::position))
  (current-stop-sequence
   :accessor current-stop-sequence
   :initform 0
   :type (cl:unsigned-byte 32))
  (stop-id
   :accessor stop-id
   :initform (pb:string-field "")
   :type pb::%sf%)
  (current-status
   :accessor current-status
   :initform transit-realtime::+vehicle-position-vehicle-stop-status-in-transit-to+
   :type transit-realtime::vehicle-position-vehicle-stop-status)
  (timestamp
   :accessor timestamp
   :initform 0
   :type (cl:unsigned-byte 64))
  (congestion-level
   :accessor congestion-level
   :initform transit-realtime::+vehicle-position-congestion-level-unknown-congestion-level+
   :type transit-realtime::vehicle-position-congestion-level)
  (occupancy-status
   :accessor occupancy-status
   :initform transit-realtime::+vehicle-position-occupancy-status-empty+
   :type transit-realtime::vehicle-position-occupancy-status)
  (%has-bits%
   :accessor %has-bits%
   :initform 0
   :type (cl:unsigned-byte 9))
  (pb::%cached-size%
   :initform 0
   :type (cl:integer 0 #.(cl:1- cl:array-dimension-limit)))
  ))

(cl:export 'vehicle-position)

(cl:export 'trip)


(cl:defmethod (cl:setf trip) :after (x (self vehicle-position))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-trip)
  (cl:defgeneric has-trip (proto)))
(cl:defmethod has-trip ((self vehicle-position))
  (cl:logbitp 0 (cl:slot-value self '%has-bits%)))
(cl:export 'has-trip)

(cl:unless (cl:fboundp 'clear-trip)
  (cl:defgeneric clear-trip (proto)))
(cl:defmethod clear-trip ((self vehicle-position))
  (cl:setf (cl:slot-value self 'trip) cl:nil)
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-trip)

(cl:export 'vehicle)


(cl:defmethod (cl:setf vehicle) :after (x (self vehicle-position))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-vehicle)
  (cl:defgeneric has-vehicle (proto)))
(cl:defmethod has-vehicle ((self vehicle-position))
  (cl:logbitp 1 (cl:slot-value self '%has-bits%)))
(cl:export 'has-vehicle)

(cl:unless (cl:fboundp 'clear-vehicle)
  (cl:defgeneric clear-vehicle (proto)))
(cl:defmethod clear-vehicle ((self vehicle-position))
  (cl:setf (cl:slot-value self 'vehicle) cl:nil)
  (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-vehicle)

(cl:export 'position)


(cl:defmethod (cl:setf position) :after (x (self vehicle-position))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-position)
  (cl:defgeneric has-position (proto)))
(cl:defmethod has-position ((self vehicle-position))
  (cl:logbitp 2 (cl:slot-value self '%has-bits%)))
(cl:export 'has-position)

(cl:unless (cl:fboundp 'clear-position)
  (cl:defgeneric clear-position (proto)))
(cl:defmethod clear-position ((self vehicle-position))
  (cl:setf (cl:slot-value self 'position) cl:nil)
  (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-position)

(cl:export 'current-stop-sequence)


(cl:defmethod (cl:setf current-stop-sequence) :after (x (self vehicle-position))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 3) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-current-stop-sequence)
  (cl:defgeneric has-current-stop-sequence (proto)))
(cl:defmethod has-current-stop-sequence ((self vehicle-position))
  (cl:logbitp 3 (cl:slot-value self '%has-bits%)))
(cl:export 'has-current-stop-sequence)

(cl:unless (cl:fboundp 'clear-current-stop-sequence)
  (cl:defgeneric clear-current-stop-sequence (proto)))
(cl:defmethod clear-current-stop-sequence ((self vehicle-position))
  (cl:setf (cl:slot-value self 'current-stop-sequence) 0)
  (cl:setf (cl:ldb (cl:byte 1 3) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-current-stop-sequence)

(cl:export 'stop-id)


(cl:defmethod (cl:setf stop-id) :after (x (self vehicle-position))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 4) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-stop-id)
  (cl:defgeneric has-stop-id (proto)))
(cl:defmethod has-stop-id ((self vehicle-position))
  (cl:logbitp 4 (cl:slot-value self '%has-bits%)))
(cl:export 'has-stop-id)

(cl:unless (cl:fboundp 'clear-stop-id)
  (cl:defgeneric clear-stop-id (proto)))
(cl:defmethod clear-stop-id ((self vehicle-position))
  (cl:setf (cl:slot-value self 'stop-id) (pb:string-field ""))
  (cl:setf (cl:ldb (cl:byte 1 4) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-stop-id)

(cl:export 'current-status)


(cl:defmethod (cl:setf current-status) :after (x (self vehicle-position))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 5) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-current-status)
  (cl:defgeneric has-current-status (proto)))
(cl:defmethod has-current-status ((self vehicle-position))
  (cl:logbitp 5 (cl:slot-value self '%has-bits%)))
(cl:export 'has-current-status)

(cl:unless (cl:fboundp 'clear-current-status)
  (cl:defgeneric clear-current-status (proto)))
(cl:defmethod clear-current-status ((self vehicle-position))
  (cl:setf (cl:slot-value self 'current-status) transit-realtime::+vehicle-position-vehicle-stop-status-in-transit-to+)
  (cl:setf (cl:ldb (cl:byte 1 5) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-current-status)

(cl:export 'timestamp)


(cl:defmethod (cl:setf timestamp) :after (x (self vehicle-position))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 6) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-timestamp)
  (cl:defgeneric has-timestamp (proto)))
(cl:defmethod has-timestamp ((self vehicle-position))
  (cl:logbitp 6 (cl:slot-value self '%has-bits%)))
(cl:export 'has-timestamp)

(cl:unless (cl:fboundp 'clear-timestamp)
  (cl:defgeneric clear-timestamp (proto)))
(cl:defmethod clear-timestamp ((self vehicle-position))
  (cl:setf (cl:slot-value self 'timestamp) 0)
  (cl:setf (cl:ldb (cl:byte 1 6) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-timestamp)

(cl:export 'congestion-level)


(cl:defmethod (cl:setf congestion-level) :after (x (self vehicle-position))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 7) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-congestion-level)
  (cl:defgeneric has-congestion-level (proto)))
(cl:defmethod has-congestion-level ((self vehicle-position))
  (cl:logbitp 7 (cl:slot-value self '%has-bits%)))
(cl:export 'has-congestion-level)

(cl:unless (cl:fboundp 'clear-congestion-level)
  (cl:defgeneric clear-congestion-level (proto)))
(cl:defmethod clear-congestion-level ((self vehicle-position))
  (cl:setf (cl:slot-value self 'congestion-level) transit-realtime::+vehicle-position-congestion-level-unknown-congestion-level+)
  (cl:setf (cl:ldb (cl:byte 1 7) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-congestion-level)

(cl:export 'occupancy-status)


(cl:defmethod (cl:setf occupancy-status) :after (x (self vehicle-position))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 8) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-occupancy-status)
  (cl:defgeneric has-occupancy-status (proto)))
(cl:defmethod has-occupancy-status ((self vehicle-position))
  (cl:logbitp 8 (cl:slot-value self '%has-bits%)))
(cl:export 'has-occupancy-status)

(cl:unless (cl:fboundp 'clear-occupancy-status)
  (cl:defgeneric clear-occupancy-status (proto)))
(cl:defmethod clear-occupancy-status ((self vehicle-position))
  (cl:setf (cl:slot-value self 'occupancy-status) transit-realtime::+vehicle-position-occupancy-status-empty+)
  (cl:setf (cl:ldb (cl:byte 1 8) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-occupancy-status)


(cl:defmethod cl:print-object ((self vehicle-position) stream)
  (cl:pprint-logical-block (stream cl:nil)
    (cl:print-unreadable-object (self stream :type cl:t :identity cl:t)
      (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_trip: ~s" (trip self)))
      (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_vehicle: ~s" (vehicle self)))
      (cl:when (cl:logbitp 2 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_position: ~s" (position self)))
      (cl:when (cl:logbitp 3 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_current-stop-sequence: ~s" (current-stop-sequence self)))
      (cl:when (cl:logbitp 4 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_stop-id: ~s" (stop-id self)))
      (cl:when (cl:logbitp 5 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_current-status: ~s" (current-status self)))
      (cl:when (cl:logbitp 6 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_timestamp: ~s" (timestamp self)))
      (cl:when (cl:logbitp 7 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_congestion-level: ~s" (congestion-level self)))
      (cl:when (cl:logbitp 8 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_occupancy-status: ~s" (occupancy-status self)))
      ))
  (cl:values))

(cl:defmethod pb:clear ((self vehicle-position))
  (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'trip) cl:nil))
  (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'vehicle) cl:nil))
  (cl:when (cl:logbitp 2 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'position) cl:nil))
  (cl:setf (cl:slot-value self 'current-stop-sequence) 0)
  (cl:when (cl:logbitp 4 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'stop-id) (pb:string-field "")))
  (cl:setf (cl:slot-value self 'current-status) transit-realtime::+vehicle-position-vehicle-stop-status-in-transit-to+)
  (cl:setf (cl:slot-value self 'timestamp) 0)
  (cl:setf (cl:slot-value self 'congestion-level) transit-realtime::+vehicle-position-congestion-level-unknown-congestion-level+)
  (cl:setf (cl:slot-value self 'occupancy-status) transit-realtime::+vehicle-position-occupancy-status-empty+)
  (cl:setf (cl:slot-value self '%has-bits%) 0)
  (cl:values))

(cl:defmethod pb:is-initialized ((self vehicle-position))
  (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
    (cl:unless (pb:is-initialized (cl:slot-value self 'trip))
      (cl:return-from pb:is-initialized cl:nil)))
  (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
    (cl:unless (pb:is-initialized (cl:slot-value self 'vehicle))
      (cl:return-from pb:is-initialized cl:nil)))
  (cl:when (cl:logbitp 2 (cl:slot-value self '%has-bits%))
    (cl:unless (pb:is-initialized (cl:slot-value self 'position))
      (cl:return-from pb:is-initialized cl:nil)))
  cl:t)

(cl:defmethod pb:octet-size ((self vehicle-position))
  (cl:let ((size 0))
    ;; optional .transit_realtime.TripDescriptor trip = 1[json_name = "trip"];
    (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
      (cl:let ((s (pb:octet-size (cl:slot-value self 'trip))))
        (cl:incf size (cl:+ 1 s (varint:length32 s)))))
    ;; optional .transit_realtime.VehicleDescriptor vehicle = 8[json_name = "vehicle"];
    (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
      (cl:let ((s (pb:octet-size (cl:slot-value self 'vehicle))))
        (cl:incf size (cl:+ 1 s (varint:length32 s)))))
    ;; optional .transit_realtime.Position position = 2[json_name = "position"];
    (cl:when (cl:logbitp 2 (cl:slot-value self '%has-bits%))
      (cl:let ((s (pb:octet-size (cl:slot-value self 'position))))
        (cl:incf size (cl:+ 1 s (varint:length32 s)))))
    ;; optional uint32 current_stop_sequence = 3[json_name = "currentStopSequence"];
    (cl:when (cl:logbitp 3 (cl:slot-value self '%has-bits%))
      (cl:incf size
        (cl:+ 1 (varint:length32 (cl:slot-value self 'current-stop-sequence)))))
    ;; optional string stop_id = 7[json_name = "stopId"];
    (cl:when (cl:logbitp 4 (cl:slot-value self '%has-bits%))
      (cl:incf size 1)
      (cl:incf size (cl:let ((s (pb::%utf8-string-length% (cl:slot-value self 'stop-id))))
        (cl:+ s (varint:length32 s)))))
    ;; optional .transit_realtime.VehiclePosition.VehicleStopStatus current_status = 4 [default = IN_TRANSIT_TO, json_name = "currentStatus"];
    (cl:when (cl:logbitp 5 (cl:slot-value self '%has-bits%))
      (cl:incf size 1)
      (cl:incf size (varint:length64 (cl:ldb (cl:byte 64 0) (cl:slot-value self 'current-status)))))
    ;; optional uint64 timestamp = 5[json_name = "timestamp"];
    (cl:when (cl:logbitp 6 (cl:slot-value self '%has-bits%))
      (cl:incf size
        (cl:+ 1 (varint:length64 (cl:slot-value self 'timestamp)))))
    ;; optional .transit_realtime.VehiclePosition.CongestionLevel congestion_level = 6[json_name = "congestionLevel"];
    (cl:when (cl:logbitp 7 (cl:slot-value self '%has-bits%))
      (cl:incf size 1)
      (cl:incf size (varint:length64 (cl:ldb (cl:byte 64 0) (cl:slot-value self 'congestion-level)))))
    ;; optional .transit_realtime.VehiclePosition.OccupancyStatus occupancy_status = 9[json_name = "occupancyStatus"];
    (cl:when (cl:logbitp 8 (cl:slot-value self '%has-bits%))
      (cl:incf size 1)
      (cl:incf size (varint:length64 (cl:ldb (cl:byte 64 0) (cl:slot-value self 'occupancy-status)))))
    (cl:setf (cl:slot-value self 'pb::%cached-size%) size)
    size))

(cl:defmethod pb:serialize ((self vehicle-position) buffer index limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index index limit)
              (cl:ignorable buffer limit))
  ;; optional .transit_realtime.TripDescriptor trip = 1[json_name = "trip"];
  (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 10))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit (cl:slot-value (cl:slot-value self 'trip) 'pb::%cached-size%)))
    (cl:setf index (pb:serialize (cl:slot-value self 'trip) buffer index limit)))
  ;; optional .transit_realtime.Position position = 2[json_name = "position"];
  (cl:when (cl:logbitp 2 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 18))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit (cl:slot-value (cl:slot-value self 'position) 'pb::%cached-size%)))
    (cl:setf index (pb:serialize (cl:slot-value self 'position) buffer index limit)))
  ;; optional uint32 current_stop_sequence = 3[json_name = "currentStopSequence"];
  (cl:when (cl:logbitp 3 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 24))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit (cl:slot-value self 'current-stop-sequence))))
  ;; optional .transit_realtime.VehiclePosition.VehicleStopStatus current_status = 4 [default = IN_TRANSIT_TO, json_name = "currentStatus"];
  (cl:when (cl:logbitp 5 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 32))
    (cl:setf index
     (varint:encode-uint64-carefully buffer index limit
      (cl:ldb (cl:byte 64 0) (cl:slot-value self 'current-status)))))
  ;; optional uint64 timestamp = 5[json_name = "timestamp"];
  (cl:when (cl:logbitp 6 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 40))
    (cl:setf index (varint:encode-uint64-carefully buffer index limit (cl:slot-value self 'timestamp))))
  ;; optional .transit_realtime.VehiclePosition.CongestionLevel congestion_level = 6[json_name = "congestionLevel"];
  (cl:when (cl:logbitp 7 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 48))
    (cl:setf index
     (varint:encode-uint64-carefully buffer index limit
      (cl:ldb (cl:byte 64 0) (cl:slot-value self 'congestion-level)))))
  ;; optional string stop_id = 7[json_name = "stopId"];
  (cl:when (cl:logbitp 4 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 58))
    (cl:setf index (wire-format:write-octets-carefully buffer index limit (cl:slot-value (cl:slot-value self 'stop-id) 'pb::%octets%))))
  ;; optional .transit_realtime.VehicleDescriptor vehicle = 8[json_name = "vehicle"];
  (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 66))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit (cl:slot-value (cl:slot-value self 'vehicle) 'pb::%cached-size%)))
    (cl:setf index (pb:serialize (cl:slot-value self 'vehicle) buffer index limit)))
  ;; optional .transit_realtime.VehiclePosition.OccupancyStatus occupancy_status = 9[json_name = "occupancyStatus"];
  (cl:when (cl:logbitp 8 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 72))
    (cl:setf index
     (varint:encode-uint64-carefully buffer index limit
      (cl:ldb (cl:byte 64 0) (cl:slot-value self 'occupancy-status)))))
  ;// Extension range [1000, 2000)
  ;DO_(_extensions_.SerializeWithCachedSizes(
  ;    1000, 2000, *this, output));

  index)

(cl:defmethod pb:merge-from-array ((self vehicle-position) buffer start limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index start limit))
  (cl:do ((index start index))
      ((cl:>= index limit) index)
    (cl:declare (cl:type com.google.base:vector-index index))
    (cl:multiple-value-bind (tag new-index)
        (varint:parse-uint32-carefully buffer index limit)
      (cl:setf index new-index)
      (cl:case tag
        ;; optional .transit_realtime.TripDescriptor trip = 1[json_name = "trip"];
        ((10)
          (cl:multiple-value-bind (length new-index)
              (varint:parse-uint31-carefully buffer index limit)
            (cl:when (cl:> (cl:+ new-index length) limit)
              (cl:error "buffer overflow"))
            (cl:let ((message (cl:slot-value self 'trip)))
              (cl:when (cl:null message)
                (cl:setf message (cl:make-instance 'transit-realtime::trip-descriptor))
                (cl:setf (cl:slot-value self 'trip) message)
                (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))
              (cl:setf index (pb:merge-from-array message buffer new-index (cl:+ new-index length)))
              (cl:when (cl:not (cl:= index (cl:+ new-index length)))
                (cl:error "buffer overflow")))))
        ;; optional .transit_realtime.Position position = 2[json_name = "position"];
        ((18)
          (cl:multiple-value-bind (length new-index)
              (varint:parse-uint31-carefully buffer index limit)
            (cl:when (cl:> (cl:+ new-index length) limit)
              (cl:error "buffer overflow"))
            (cl:let ((message (cl:slot-value self 'position)))
              (cl:when (cl:null message)
                (cl:setf message (cl:make-instance 'transit-realtime::position))
                (cl:setf (cl:slot-value self 'position) message)
                (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 1))
              (cl:setf index (pb:merge-from-array message buffer new-index (cl:+ new-index length)))
              (cl:when (cl:not (cl:= index (cl:+ new-index length)))
                (cl:error "buffer overflow")))))
        ;; optional uint32 current_stop_sequence = 3[json_name = "currentStopSequence"];
        ((24)
          (cl:multiple-value-bind (value new-index)
              (varint:parse-uint32-carefully buffer index limit)
            (cl:setf (cl:slot-value self 'current-stop-sequence) value)
            (cl:setf (cl:ldb (cl:byte 1 3) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        ;; optional .transit_realtime.VehiclePosition.VehicleStopStatus current_status = 4 [default = IN_TRANSIT_TO, json_name = "currentStatus"];
        ((32)
          (cl:multiple-value-bind (value new-index)
              (varint:parse-int32-carefully buffer index limit)
            ;; XXXXX: when valid, set field, else add to unknown fields
            (cl:setf (cl:slot-value self 'current-status) value)
            (cl:setf (cl:ldb (cl:byte 1 5) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        ;; optional uint64 timestamp = 5[json_name = "timestamp"];
        ((40)
          (cl:multiple-value-bind (value new-index)
              (varint:parse-uint64-carefully buffer index limit)
            (cl:setf (cl:slot-value self 'timestamp) value)
            (cl:setf (cl:ldb (cl:byte 1 6) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        ;; optional .transit_realtime.VehiclePosition.CongestionLevel congestion_level = 6[json_name = "congestionLevel"];
        ((48)
          (cl:multiple-value-bind (value new-index)
              (varint:parse-int32-carefully buffer index limit)
            ;; XXXXX: when valid, set field, else add to unknown fields
            (cl:setf (cl:slot-value self 'congestion-level) value)
            (cl:setf (cl:ldb (cl:byte 1 7) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        ;; optional string stop_id = 7[json_name = "stopId"];
        ((58)
          (cl:multiple-value-bind (value new-index)
              (wire-format:read-octets-carefully buffer index limit)
            (cl:setf (cl:slot-value self 'stop-id) (pb:string-field value))
            (cl:setf (cl:ldb (cl:byte 1 4) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        ;; optional .transit_realtime.VehicleDescriptor vehicle = 8[json_name = "vehicle"];
        ((66)
          (cl:multiple-value-bind (length new-index)
              (varint:parse-uint31-carefully buffer index limit)
            (cl:when (cl:> (cl:+ new-index length) limit)
              (cl:error "buffer overflow"))
            (cl:let ((message (cl:slot-value self 'vehicle)))
              (cl:when (cl:null message)
                (cl:setf message (cl:make-instance 'transit-realtime::vehicle-descriptor))
                (cl:setf (cl:slot-value self 'vehicle) message)
                (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1))
              (cl:setf index (pb:merge-from-array message buffer new-index (cl:+ new-index length)))
              (cl:when (cl:not (cl:= index (cl:+ new-index length)))
                (cl:error "buffer overflow")))))
        ;; optional .transit_realtime.VehiclePosition.OccupancyStatus occupancy_status = 9[json_name = "occupancyStatus"];
        ((72)
          (cl:multiple-value-bind (value new-index)
              (varint:parse-int32-carefully buffer index limit)
            ;; XXXXX: when valid, set field, else add to unknown fields
            (cl:setf (cl:slot-value self 'occupancy-status) value)
            (cl:setf (cl:ldb (cl:byte 1 8) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        (cl:t
          (cl:when (cl:= (cl:logand tag 7) 4)
            (cl:return-from pb:merge-from-array index))
          (cl:setf index (wire-format:skip-field buffer index limit tag)))))))

(cl:defmethod pb:merge-from-message ((self vehicle-position) (from vehicle-position))
  (cl:when (cl:logbitp 0 (cl:slot-value from '%has-bits%))
    (cl:let ((message (cl:slot-value self 'trip)))
      (cl:when (cl:null message)
        (cl:setf message (cl:make-instance 'transit-realtime::trip-descriptor))
        (cl:setf (cl:slot-value self 'trip) message)
        (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))
     (pb:merge-from-message message (cl:slot-value from 'trip))))
  (cl:when (cl:logbitp 1 (cl:slot-value from '%has-bits%))
    (cl:let ((message (cl:slot-value self 'vehicle)))
      (cl:when (cl:null message)
        (cl:setf message (cl:make-instance 'transit-realtime::vehicle-descriptor))
        (cl:setf (cl:slot-value self 'vehicle) message)
        (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1))
     (pb:merge-from-message message (cl:slot-value from 'vehicle))))
  (cl:when (cl:logbitp 2 (cl:slot-value from '%has-bits%))
    (cl:let ((message (cl:slot-value self 'position)))
      (cl:when (cl:null message)
        (cl:setf message (cl:make-instance 'transit-realtime::position))
        (cl:setf (cl:slot-value self 'position) message)
        (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 1))
     (pb:merge-from-message message (cl:slot-value from 'position))))
  (cl:when (cl:logbitp 3 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'current-stop-sequence) (cl:slot-value from 'current-stop-sequence))
    (cl:setf (cl:ldb (cl:byte 1 3) (cl:slot-value self '%has-bits%)) 1))
  (cl:when (cl:logbitp 4 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'stop-id) (cl:slot-value from 'stop-id))
    (cl:setf (cl:ldb (cl:byte 1 4) (cl:slot-value self '%has-bits%)) 1))
  (cl:when (cl:logbitp 5 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'current-status) (cl:slot-value from 'current-status))
    (cl:setf (cl:ldb (cl:byte 1 5) (cl:slot-value self '%has-bits%)) 1))
  (cl:when (cl:logbitp 6 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'timestamp) (cl:slot-value from 'timestamp))
    (cl:setf (cl:ldb (cl:byte 1 6) (cl:slot-value self '%has-bits%)) 1))
  (cl:when (cl:logbitp 7 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'congestion-level) (cl:slot-value from 'congestion-level))
    (cl:setf (cl:ldb (cl:byte 1 7) (cl:slot-value self '%has-bits%)) 1))
  (cl:when (cl:logbitp 8 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'occupancy-status) (cl:slot-value from 'occupancy-status))
    (cl:setf (cl:ldb (cl:byte 1 8) (cl:slot-value self '%has-bits%)) 1))
)


(cl:defclass alert (pb:protocol-buffer)
  (
  (active-period
   :accessor active-period
   :initform (cl:make-array
              0
              :element-type 'transit-realtime::time-range
              :fill-pointer 0 :adjustable cl:t)
   :type (cl:vector transit-realtime::time-range))
  (informed-entity
   :accessor informed-entity
   :initform (cl:make-array
              0
              :element-type 'transit-realtime::entity-selector
              :fill-pointer 0 :adjustable cl:t)
   :type (cl:vector transit-realtime::entity-selector))
  (cause
   :accessor cause
   :initform transit-realtime::+alert-cause-unknown-cause+
   :type transit-realtime::alert-cause)
  (effect
   :accessor effect
   :initform transit-realtime::+alert-effect-unknown-effect+
   :type transit-realtime::alert-effect)
  (url
   :accessor url
   :initform cl:nil
   :type (cl:or cl:null transit-realtime::translated-string))
  (header-text
   :accessor header-text
   :initform cl:nil
   :type (cl:or cl:null transit-realtime::translated-string))
  (description-text
   :accessor description-text
   :initform cl:nil
   :type (cl:or cl:null transit-realtime::translated-string))
  (%has-bits%
   :accessor %has-bits%
   :initform 0
   :type (cl:unsigned-byte 7))
  (pb::%cached-size%
   :initform 0
   :type (cl:integer 0 #.(cl:1- cl:array-dimension-limit)))
  ))

(cl:export 'alert)

(cl:export 'active-period)

(cl:unless (cl:fboundp 'clear-active-period)
  (cl:defgeneric clear-active-period (proto)))
(cl:defmethod clear-active-period ((self alert))
  (cl:setf (cl:slot-value self 'active-period)
           (cl:make-array 0 :element-type 'transit-realtime::time-range
            :fill-pointer 0 :adjustable cl:t))
  (cl:values))
(cl:export 'clear-active-period)

(cl:export 'informed-entity)

(cl:unless (cl:fboundp 'clear-informed-entity)
  (cl:defgeneric clear-informed-entity (proto)))
(cl:defmethod clear-informed-entity ((self alert))
  (cl:setf (cl:slot-value self 'informed-entity)
           (cl:make-array 0 :element-type 'transit-realtime::entity-selector
            :fill-pointer 0 :adjustable cl:t))
  (cl:values))
(cl:export 'clear-informed-entity)

(cl:export 'cause)


(cl:defmethod (cl:setf cause) :after (x (self alert))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-cause)
  (cl:defgeneric has-cause (proto)))
(cl:defmethod has-cause ((self alert))
  (cl:logbitp 2 (cl:slot-value self '%has-bits%)))
(cl:export 'has-cause)

(cl:unless (cl:fboundp 'clear-cause)
  (cl:defgeneric clear-cause (proto)))
(cl:defmethod clear-cause ((self alert))
  (cl:setf (cl:slot-value self 'cause) transit-realtime::+alert-cause-unknown-cause+)
  (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-cause)

(cl:export 'effect)


(cl:defmethod (cl:setf effect) :after (x (self alert))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 3) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-effect)
  (cl:defgeneric has-effect (proto)))
(cl:defmethod has-effect ((self alert))
  (cl:logbitp 3 (cl:slot-value self '%has-bits%)))
(cl:export 'has-effect)

(cl:unless (cl:fboundp 'clear-effect)
  (cl:defgeneric clear-effect (proto)))
(cl:defmethod clear-effect ((self alert))
  (cl:setf (cl:slot-value self 'effect) transit-realtime::+alert-effect-unknown-effect+)
  (cl:setf (cl:ldb (cl:byte 1 3) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-effect)

(cl:export 'url)


(cl:defmethod (cl:setf url) :after (x (self alert))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 4) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-url)
  (cl:defgeneric has-url (proto)))
(cl:defmethod has-url ((self alert))
  (cl:logbitp 4 (cl:slot-value self '%has-bits%)))
(cl:export 'has-url)

(cl:unless (cl:fboundp 'clear-url)
  (cl:defgeneric clear-url (proto)))
(cl:defmethod clear-url ((self alert))
  (cl:setf (cl:slot-value self 'url) cl:nil)
  (cl:setf (cl:ldb (cl:byte 1 4) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-url)

(cl:export 'header-text)


(cl:defmethod (cl:setf header-text) :after (x (self alert))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 5) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-header-text)
  (cl:defgeneric has-header-text (proto)))
(cl:defmethod has-header-text ((self alert))
  (cl:logbitp 5 (cl:slot-value self '%has-bits%)))
(cl:export 'has-header-text)

(cl:unless (cl:fboundp 'clear-header-text)
  (cl:defgeneric clear-header-text (proto)))
(cl:defmethod clear-header-text ((self alert))
  (cl:setf (cl:slot-value self 'header-text) cl:nil)
  (cl:setf (cl:ldb (cl:byte 1 5) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-header-text)

(cl:export 'description-text)


(cl:defmethod (cl:setf description-text) :after (x (self alert))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 6) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-description-text)
  (cl:defgeneric has-description-text (proto)))
(cl:defmethod has-description-text ((self alert))
  (cl:logbitp 6 (cl:slot-value self '%has-bits%)))
(cl:export 'has-description-text)

(cl:unless (cl:fboundp 'clear-description-text)
  (cl:defgeneric clear-description-text (proto)))
(cl:defmethod clear-description-text ((self alert))
  (cl:setf (cl:slot-value self 'description-text) cl:nil)
  (cl:setf (cl:ldb (cl:byte 1 6) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-description-text)


(cl:defmethod cl:print-object ((self alert) stream)
  (cl:pprint-logical-block (stream cl:nil)
    (cl:print-unreadable-object (self stream :type cl:t :identity cl:t)
      (cl:format stream " ~_active-period: ~s" (active-period self))
      (cl:format stream " ~_informed-entity: ~s" (informed-entity self))
      (cl:when (cl:logbitp 2 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_cause: ~s" (cause self)))
      (cl:when (cl:logbitp 3 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_effect: ~s" (effect self)))
      (cl:when (cl:logbitp 4 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_url: ~s" (url self)))
      (cl:when (cl:logbitp 5 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_header-text: ~s" (header-text self)))
      (cl:when (cl:logbitp 6 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_description-text: ~s" (description-text self)))
      ))
  (cl:values))

(cl:defmethod pb:clear ((self alert))
  (cl:setf (cl:slot-value self 'cause) transit-realtime::+alert-cause-unknown-cause+)
  (cl:setf (cl:slot-value self 'effect) transit-realtime::+alert-effect-unknown-effect+)
  (cl:when (cl:logbitp 4 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'url) cl:nil))
  (cl:when (cl:logbitp 5 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'header-text) cl:nil))
  (cl:when (cl:logbitp 6 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'description-text) cl:nil))
  (cl:setf (cl:slot-value self 'active-period)
           (cl:make-array 0 :element-type 'transit-realtime::time-range
            :fill-pointer 0 :adjustable cl:t))
  (cl:setf (cl:slot-value self 'informed-entity)
           (cl:make-array 0 :element-type 'transit-realtime::entity-selector
            :fill-pointer 0 :adjustable cl:t))
  (cl:setf (cl:slot-value self '%has-bits%) 0)
  (cl:values))

(cl:defmethod pb:is-initialized ((self alert))
  (cl:let* ((x (cl:slot-value self 'active-period))
            (length (cl:length x)))
    (cl:dotimes (i length)
      (cl:unless (pb:is-initialized (cl:aref x i))
        (cl:return-from pb:is-initialized cl:nil))))
  (cl:let* ((x (cl:slot-value self 'informed-entity))
            (length (cl:length x)))
    (cl:dotimes (i length)
      (cl:unless (pb:is-initialized (cl:aref x i))
        (cl:return-from pb:is-initialized cl:nil))))
  (cl:when (cl:logbitp 4 (cl:slot-value self '%has-bits%))
    (cl:unless (pb:is-initialized (cl:slot-value self 'url))
      (cl:return-from pb:is-initialized cl:nil)))
  (cl:when (cl:logbitp 5 (cl:slot-value self '%has-bits%))
    (cl:unless (pb:is-initialized (cl:slot-value self 'header-text))
      (cl:return-from pb:is-initialized cl:nil)))
  (cl:when (cl:logbitp 6 (cl:slot-value self '%has-bits%))
    (cl:unless (pb:is-initialized (cl:slot-value self 'description-text))
      (cl:return-from pb:is-initialized cl:nil)))
  cl:t)

(cl:defmethod pb:octet-size ((self alert))
  (cl:let ((size 0))
    ;; optional .transit_realtime.Alert.Cause cause = 6 [default = UNKNOWN_CAUSE, json_name = "cause"];
    (cl:when (cl:logbitp 2 (cl:slot-value self '%has-bits%))
      (cl:incf size 1)
      (cl:incf size (varint:length64 (cl:ldb (cl:byte 64 0) (cl:slot-value self 'cause)))))
    ;; optional .transit_realtime.Alert.Effect effect = 7 [default = UNKNOWN_EFFECT, json_name = "effect"];
    (cl:when (cl:logbitp 3 (cl:slot-value self '%has-bits%))
      (cl:incf size 1)
      (cl:incf size (varint:length64 (cl:ldb (cl:byte 64 0) (cl:slot-value self 'effect)))))
    ;; optional .transit_realtime.TranslatedString url = 8[json_name = "url"];
    (cl:when (cl:logbitp 4 (cl:slot-value self '%has-bits%))
      (cl:let ((s (pb:octet-size (cl:slot-value self 'url))))
        (cl:incf size (cl:+ 1 s (varint:length32 s)))))
    ;; optional .transit_realtime.TranslatedString header_text = 10[json_name = "headerText"];
    (cl:when (cl:logbitp 5 (cl:slot-value self '%has-bits%))
      (cl:let ((s (pb:octet-size (cl:slot-value self 'header-text))))
        (cl:incf size (cl:+ 1 s (varint:length32 s)))))
    ;; optional .transit_realtime.TranslatedString description_text = 11[json_name = "descriptionText"];
    (cl:when (cl:logbitp 6 (cl:slot-value self '%has-bits%))
      (cl:let ((s (pb:octet-size (cl:slot-value self 'description-text))))
        (cl:incf size (cl:+ 1 s (varint:length32 s)))))
    ;; repeated .transit_realtime.TimeRange active_period = 1[json_name = "activePeriod"];
    (cl:let* ((v (cl:slot-value self 'active-period))
              (length (cl:length v)))
      (cl:incf size (cl:* 1 length))
      (cl:dotimes (i length)
        (cl:let ((s (pb:octet-size (cl:aref v i))))
          (cl:incf size (cl:+ s (varint:length32 s))))))
    ;; repeated .transit_realtime.EntitySelector informed_entity = 5[json_name = "informedEntity"];
    (cl:let* ((v (cl:slot-value self 'informed-entity))
              (length (cl:length v)))
      (cl:incf size (cl:* 1 length))
      (cl:dotimes (i length)
        (cl:let ((s (pb:octet-size (cl:aref v i))))
          (cl:incf size (cl:+ s (varint:length32 s))))))
    (cl:setf (cl:slot-value self 'pb::%cached-size%) size)
    size))

(cl:defmethod pb:serialize ((self alert) buffer index limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index index limit)
              (cl:ignorable buffer limit))
  ;; repeated .transit_realtime.TimeRange active_period = 1[json_name = "activePeriod"];
  (cl:let* ((v (cl:slot-value self 'active-period))
            (length (cl:length v)))
    (cl:loop for i from 0 below length do
       (cl:setf index (varint:encode-uint32-carefully buffer index limit 10))
       (cl:setf index (varint:encode-uint32-carefully buffer index limit (cl:slot-value (cl:aref v i) 'pb::%cached-size%)))
       (cl:setf index (pb:serialize (cl:aref v i) buffer index limit))))
  ;; repeated .transit_realtime.EntitySelector informed_entity = 5[json_name = "informedEntity"];
  (cl:let* ((v (cl:slot-value self 'informed-entity))
            (length (cl:length v)))
    (cl:loop for i from 0 below length do
       (cl:setf index (varint:encode-uint32-carefully buffer index limit 42))
       (cl:setf index (varint:encode-uint32-carefully buffer index limit (cl:slot-value (cl:aref v i) 'pb::%cached-size%)))
       (cl:setf index (pb:serialize (cl:aref v i) buffer index limit))))
  ;; optional .transit_realtime.Alert.Cause cause = 6 [default = UNKNOWN_CAUSE, json_name = "cause"];
  (cl:when (cl:logbitp 2 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 48))
    (cl:setf index
     (varint:encode-uint64-carefully buffer index limit
      (cl:ldb (cl:byte 64 0) (cl:slot-value self 'cause)))))
  ;; optional .transit_realtime.Alert.Effect effect = 7 [default = UNKNOWN_EFFECT, json_name = "effect"];
  (cl:when (cl:logbitp 3 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 56))
    (cl:setf index
     (varint:encode-uint64-carefully buffer index limit
      (cl:ldb (cl:byte 64 0) (cl:slot-value self 'effect)))))
  ;; optional .transit_realtime.TranslatedString url = 8[json_name = "url"];
  (cl:when (cl:logbitp 4 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 66))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit (cl:slot-value (cl:slot-value self 'url) 'pb::%cached-size%)))
    (cl:setf index (pb:serialize (cl:slot-value self 'url) buffer index limit)))
  ;; optional .transit_realtime.TranslatedString header_text = 10[json_name = "headerText"];
  (cl:when (cl:logbitp 5 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 82))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit (cl:slot-value (cl:slot-value self 'header-text) 'pb::%cached-size%)))
    (cl:setf index (pb:serialize (cl:slot-value self 'header-text) buffer index limit)))
  ;; optional .transit_realtime.TranslatedString description_text = 11[json_name = "descriptionText"];
  (cl:when (cl:logbitp 6 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 90))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit (cl:slot-value (cl:slot-value self 'description-text) 'pb::%cached-size%)))
    (cl:setf index (pb:serialize (cl:slot-value self 'description-text) buffer index limit)))
  ;// Extension range [1000, 2000)
  ;DO_(_extensions_.SerializeWithCachedSizes(
  ;    1000, 2000, *this, output));

  index)

(cl:defmethod pb:merge-from-array ((self alert) buffer start limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index start limit))
  (cl:do ((index start index))
      ((cl:>= index limit) index)
    (cl:declare (cl:type com.google.base:vector-index index))
    (cl:multiple-value-bind (tag new-index)
        (varint:parse-uint32-carefully buffer index limit)
      (cl:setf index new-index)
      (cl:case tag
        ;; repeated .transit_realtime.TimeRange active_period = 1[json_name = "activePeriod"];
        ((10)
          (cl:multiple-value-bind (length new-index)
              (varint:parse-uint31-carefully buffer index limit)
            (cl:when (cl:> (cl:+ new-index length) limit)
              (cl:error "buffer overflow"))
            (cl:let ((message (cl:make-instance 'transit-realtime::time-range)))
              (cl:setf index (pb:merge-from-array message buffer new-index (cl:+ new-index length)))
              (cl:when (cl:not (cl:= index (cl:+ new-index length)))
                (cl:error "buffer overflow"))
              (cl:vector-push-extend message (cl:slot-value self 'active-period)))))
        ;; repeated .transit_realtime.EntitySelector informed_entity = 5[json_name = "informedEntity"];
        ((42)
          (cl:multiple-value-bind (length new-index)
              (varint:parse-uint31-carefully buffer index limit)
            (cl:when (cl:> (cl:+ new-index length) limit)
              (cl:error "buffer overflow"))
            (cl:let ((message (cl:make-instance 'transit-realtime::entity-selector)))
              (cl:setf index (pb:merge-from-array message buffer new-index (cl:+ new-index length)))
              (cl:when (cl:not (cl:= index (cl:+ new-index length)))
                (cl:error "buffer overflow"))
              (cl:vector-push-extend message (cl:slot-value self 'informed-entity)))))
        ;; optional .transit_realtime.Alert.Cause cause = 6 [default = UNKNOWN_CAUSE, json_name = "cause"];
        ((48)
          (cl:multiple-value-bind (value new-index)
              (varint:parse-int32-carefully buffer index limit)
            ;; XXXXX: when valid, set field, else add to unknown fields
            (cl:setf (cl:slot-value self 'cause) value)
            (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        ;; optional .transit_realtime.Alert.Effect effect = 7 [default = UNKNOWN_EFFECT, json_name = "effect"];
        ((56)
          (cl:multiple-value-bind (value new-index)
              (varint:parse-int32-carefully buffer index limit)
            ;; XXXXX: when valid, set field, else add to unknown fields
            (cl:setf (cl:slot-value self 'effect) value)
            (cl:setf (cl:ldb (cl:byte 1 3) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        ;; optional .transit_realtime.TranslatedString url = 8[json_name = "url"];
        ((66)
          (cl:multiple-value-bind (length new-index)
              (varint:parse-uint31-carefully buffer index limit)
            (cl:when (cl:> (cl:+ new-index length) limit)
              (cl:error "buffer overflow"))
            (cl:let ((message (cl:slot-value self 'url)))
              (cl:when (cl:null message)
                (cl:setf message (cl:make-instance 'transit-realtime::translated-string))
                (cl:setf (cl:slot-value self 'url) message)
                (cl:setf (cl:ldb (cl:byte 1 4) (cl:slot-value self '%has-bits%)) 1))
              (cl:setf index (pb:merge-from-array message buffer new-index (cl:+ new-index length)))
              (cl:when (cl:not (cl:= index (cl:+ new-index length)))
                (cl:error "buffer overflow")))))
        ;; optional .transit_realtime.TranslatedString header_text = 10[json_name = "headerText"];
        ((82)
          (cl:multiple-value-bind (length new-index)
              (varint:parse-uint31-carefully buffer index limit)
            (cl:when (cl:> (cl:+ new-index length) limit)
              (cl:error "buffer overflow"))
            (cl:let ((message (cl:slot-value self 'header-text)))
              (cl:when (cl:null message)
                (cl:setf message (cl:make-instance 'transit-realtime::translated-string))
                (cl:setf (cl:slot-value self 'header-text) message)
                (cl:setf (cl:ldb (cl:byte 1 5) (cl:slot-value self '%has-bits%)) 1))
              (cl:setf index (pb:merge-from-array message buffer new-index (cl:+ new-index length)))
              (cl:when (cl:not (cl:= index (cl:+ new-index length)))
                (cl:error "buffer overflow")))))
        ;; optional .transit_realtime.TranslatedString description_text = 11[json_name = "descriptionText"];
        ((90)
          (cl:multiple-value-bind (length new-index)
              (varint:parse-uint31-carefully buffer index limit)
            (cl:when (cl:> (cl:+ new-index length) limit)
              (cl:error "buffer overflow"))
            (cl:let ((message (cl:slot-value self 'description-text)))
              (cl:when (cl:null message)
                (cl:setf message (cl:make-instance 'transit-realtime::translated-string))
                (cl:setf (cl:slot-value self 'description-text) message)
                (cl:setf (cl:ldb (cl:byte 1 6) (cl:slot-value self '%has-bits%)) 1))
              (cl:setf index (pb:merge-from-array message buffer new-index (cl:+ new-index length)))
              (cl:when (cl:not (cl:= index (cl:+ new-index length)))
                (cl:error "buffer overflow")))))
        (cl:t
          (cl:when (cl:= (cl:logand tag 7) 4)
            (cl:return-from pb:merge-from-array index))
          (cl:setf index (wire-format:skip-field buffer index limit tag)))))))

(cl:defmethod pb:merge-from-message ((self alert) (from alert))
  (cl:let* ((v (cl:slot-value self 'active-period))
            (vf (cl:slot-value from 'active-period))
            (length (cl:length vf)))
    (cl:loop for i from 0 below length do
      (cl:vector-push-extend (cl:aref vf i) v)))
  (cl:let* ((v (cl:slot-value self 'informed-entity))
            (vf (cl:slot-value from 'informed-entity))
            (length (cl:length vf)))
    (cl:loop for i from 0 below length do
      (cl:vector-push-extend (cl:aref vf i) v)))
  (cl:when (cl:logbitp 2 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'cause) (cl:slot-value from 'cause))
    (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 1))
  (cl:when (cl:logbitp 3 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'effect) (cl:slot-value from 'effect))
    (cl:setf (cl:ldb (cl:byte 1 3) (cl:slot-value self '%has-bits%)) 1))
  (cl:when (cl:logbitp 4 (cl:slot-value from '%has-bits%))
    (cl:let ((message (cl:slot-value self 'url)))
      (cl:when (cl:null message)
        (cl:setf message (cl:make-instance 'transit-realtime::translated-string))
        (cl:setf (cl:slot-value self 'url) message)
        (cl:setf (cl:ldb (cl:byte 1 4) (cl:slot-value self '%has-bits%)) 1))
     (pb:merge-from-message message (cl:slot-value from 'url))))
  (cl:when (cl:logbitp 5 (cl:slot-value from '%has-bits%))
    (cl:let ((message (cl:slot-value self 'header-text)))
      (cl:when (cl:null message)
        (cl:setf message (cl:make-instance 'transit-realtime::translated-string))
        (cl:setf (cl:slot-value self 'header-text) message)
        (cl:setf (cl:ldb (cl:byte 1 5) (cl:slot-value self '%has-bits%)) 1))
     (pb:merge-from-message message (cl:slot-value from 'header-text))))
  (cl:when (cl:logbitp 6 (cl:slot-value from '%has-bits%))
    (cl:let ((message (cl:slot-value self 'description-text)))
      (cl:when (cl:null message)
        (cl:setf message (cl:make-instance 'transit-realtime::translated-string))
        (cl:setf (cl:slot-value self 'description-text) message)
        (cl:setf (cl:ldb (cl:byte 1 6) (cl:slot-value self '%has-bits%)) 1))
     (pb:merge-from-message message (cl:slot-value from 'description-text))))
)


(cl:defclass time-range (pb:protocol-buffer)
  (
  (start
   :accessor start
   :initform 0
   :type (cl:unsigned-byte 64))
  (end
   :accessor end
   :initform 0
   :type (cl:unsigned-byte 64))
  (%has-bits%
   :accessor %has-bits%
   :initform 0
   :type (cl:unsigned-byte 2))
  (pb::%cached-size%
   :initform 0
   :type (cl:integer 0 #.(cl:1- cl:array-dimension-limit)))
  ))

(cl:export 'time-range)

(cl:export 'start)


(cl:defmethod (cl:setf start) :after (x (self time-range))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-start)
  (cl:defgeneric has-start (proto)))
(cl:defmethod has-start ((self time-range))
  (cl:logbitp 0 (cl:slot-value self '%has-bits%)))
(cl:export 'has-start)

(cl:unless (cl:fboundp 'clear-start)
  (cl:defgeneric clear-start (proto)))
(cl:defmethod clear-start ((self time-range))
  (cl:setf (cl:slot-value self 'start) 0)
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-start)

(cl:export 'end)


(cl:defmethod (cl:setf end) :after (x (self time-range))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-end)
  (cl:defgeneric has-end (proto)))
(cl:defmethod has-end ((self time-range))
  (cl:logbitp 1 (cl:slot-value self '%has-bits%)))
(cl:export 'has-end)

(cl:unless (cl:fboundp 'clear-end)
  (cl:defgeneric clear-end (proto)))
(cl:defmethod clear-end ((self time-range))
  (cl:setf (cl:slot-value self 'end) 0)
  (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-end)


(cl:defmethod cl:print-object ((self time-range) stream)
  (cl:pprint-logical-block (stream cl:nil)
    (cl:print-unreadable-object (self stream :type cl:t :identity cl:t)
      (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_start: ~s" (start self)))
      (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_end: ~s" (end self)))
      ))
  (cl:values))

(cl:defmethod pb:clear ((self time-range))
  (cl:setf (cl:slot-value self 'start) 0)
  (cl:setf (cl:slot-value self 'end) 0)
  (cl:setf (cl:slot-value self '%has-bits%) 0)
  (cl:values))

(cl:defmethod pb:is-initialized ((self time-range))
  cl:t)

(cl:defmethod pb:octet-size ((self time-range))
  (cl:let ((size 0))
    ;; optional uint64 start = 1[json_name = "start"];
    (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
      (cl:incf size
        (cl:+ 1 (varint:length64 (cl:slot-value self 'start)))))
    ;; optional uint64 end = 2[json_name = "end"];
    (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
      (cl:incf size
        (cl:+ 1 (varint:length64 (cl:slot-value self 'end)))))
    (cl:setf (cl:slot-value self 'pb::%cached-size%) size)
    size))

(cl:defmethod pb:serialize ((self time-range) buffer index limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index index limit)
              (cl:ignorable buffer limit))
  ;; optional uint64 start = 1[json_name = "start"];
  (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 8))
    (cl:setf index (varint:encode-uint64-carefully buffer index limit (cl:slot-value self 'start))))
  ;; optional uint64 end = 2[json_name = "end"];
  (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 16))
    (cl:setf index (varint:encode-uint64-carefully buffer index limit (cl:slot-value self 'end))))
  ;// Extension range [1000, 2000)
  ;DO_(_extensions_.SerializeWithCachedSizes(
  ;    1000, 2000, *this, output));

  index)

(cl:defmethod pb:merge-from-array ((self time-range) buffer start limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index start limit))
  (cl:do ((index start index))
      ((cl:>= index limit) index)
    (cl:declare (cl:type com.google.base:vector-index index))
    (cl:multiple-value-bind (tag new-index)
        (varint:parse-uint32-carefully buffer index limit)
      (cl:setf index new-index)
      (cl:case tag
        ;; optional uint64 start = 1[json_name = "start"];
        ((8)
          (cl:multiple-value-bind (value new-index)
              (varint:parse-uint64-carefully buffer index limit)
            (cl:setf (cl:slot-value self 'start) value)
            (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        ;; optional uint64 end = 2[json_name = "end"];
        ((16)
          (cl:multiple-value-bind (value new-index)
              (varint:parse-uint64-carefully buffer index limit)
            (cl:setf (cl:slot-value self 'end) value)
            (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        (cl:t
          (cl:when (cl:= (cl:logand tag 7) 4)
            (cl:return-from pb:merge-from-array index))
          (cl:setf index (wire-format:skip-field buffer index limit tag)))))))

(cl:defmethod pb:merge-from-message ((self time-range) (from time-range))
  (cl:when (cl:logbitp 0 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'start) (cl:slot-value from 'start))
    (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))
  (cl:when (cl:logbitp 1 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'end) (cl:slot-value from 'end))
    (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1))
)


(cl:defclass position (pb:protocol-buffer)
  (
  (latitude
   :accessor latitude
   :initform 0f0
   :type cl:single-float)
  (longitude
   :accessor longitude
   :initform 0f0
   :type cl:single-float)
  (bearing
   :accessor bearing
   :initform 0f0
   :type cl:single-float)
  (odometer
   :accessor odometer
   :initform 0d0
   :type cl:double-float)
  (speed
   :accessor speed
   :initform 0f0
   :type cl:single-float)
  (%has-bits%
   :accessor %has-bits%
   :initform 0
   :type (cl:unsigned-byte 5))
  (pb::%cached-size%
   :initform 0
   :type (cl:integer 0 #.(cl:1- cl:array-dimension-limit)))
  ))

(cl:export 'position)

(cl:export 'latitude)


(cl:defmethod (cl:setf latitude) :after (x (self position))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-latitude)
  (cl:defgeneric has-latitude (proto)))
(cl:defmethod has-latitude ((self position))
  (cl:logbitp 0 (cl:slot-value self '%has-bits%)))
(cl:export 'has-latitude)

(cl:unless (cl:fboundp 'clear-latitude)
  (cl:defgeneric clear-latitude (proto)))
(cl:defmethod clear-latitude ((self position))
  (cl:setf (cl:slot-value self 'latitude) 0f0)
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-latitude)

(cl:export 'longitude)


(cl:defmethod (cl:setf longitude) :after (x (self position))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-longitude)
  (cl:defgeneric has-longitude (proto)))
(cl:defmethod has-longitude ((self position))
  (cl:logbitp 1 (cl:slot-value self '%has-bits%)))
(cl:export 'has-longitude)

(cl:unless (cl:fboundp 'clear-longitude)
  (cl:defgeneric clear-longitude (proto)))
(cl:defmethod clear-longitude ((self position))
  (cl:setf (cl:slot-value self 'longitude) 0f0)
  (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-longitude)

(cl:export 'bearing)


(cl:defmethod (cl:setf bearing) :after (x (self position))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-bearing)
  (cl:defgeneric has-bearing (proto)))
(cl:defmethod has-bearing ((self position))
  (cl:logbitp 2 (cl:slot-value self '%has-bits%)))
(cl:export 'has-bearing)

(cl:unless (cl:fboundp 'clear-bearing)
  (cl:defgeneric clear-bearing (proto)))
(cl:defmethod clear-bearing ((self position))
  (cl:setf (cl:slot-value self 'bearing) 0f0)
  (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-bearing)

(cl:export 'odometer)


(cl:defmethod (cl:setf odometer) :after (x (self position))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 3) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-odometer)
  (cl:defgeneric has-odometer (proto)))
(cl:defmethod has-odometer ((self position))
  (cl:logbitp 3 (cl:slot-value self '%has-bits%)))
(cl:export 'has-odometer)

(cl:unless (cl:fboundp 'clear-odometer)
  (cl:defgeneric clear-odometer (proto)))
(cl:defmethod clear-odometer ((self position))
  (cl:setf (cl:slot-value self 'odometer) 0d0)
  (cl:setf (cl:ldb (cl:byte 1 3) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-odometer)

(cl:export 'speed)


(cl:defmethod (cl:setf speed) :after (x (self position))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 4) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-speed)
  (cl:defgeneric has-speed (proto)))
(cl:defmethod has-speed ((self position))
  (cl:logbitp 4 (cl:slot-value self '%has-bits%)))
(cl:export 'has-speed)

(cl:unless (cl:fboundp 'clear-speed)
  (cl:defgeneric clear-speed (proto)))
(cl:defmethod clear-speed ((self position))
  (cl:setf (cl:slot-value self 'speed) 0f0)
  (cl:setf (cl:ldb (cl:byte 1 4) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-speed)


(cl:defmethod cl:print-object ((self position) stream)
  (cl:pprint-logical-block (stream cl:nil)
    (cl:print-unreadable-object (self stream :type cl:t :identity cl:t)
      (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_latitude: ~s" (latitude self)))
      (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_longitude: ~s" (longitude self)))
      (cl:when (cl:logbitp 2 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_bearing: ~s" (bearing self)))
      (cl:when (cl:logbitp 3 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_odometer: ~s" (odometer self)))
      (cl:when (cl:logbitp 4 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_speed: ~s" (speed self)))
      ))
  (cl:values))

(cl:defmethod pb:clear ((self position))
  (cl:setf (cl:slot-value self 'latitude) 0f0)
  (cl:setf (cl:slot-value self 'longitude) 0f0)
  (cl:setf (cl:slot-value self 'bearing) 0f0)
  (cl:setf (cl:slot-value self 'odometer) 0d0)
  (cl:setf (cl:slot-value self 'speed) 0f0)
  (cl:setf (cl:slot-value self '%has-bits%) 0)
  (cl:values))

(cl:defmethod pb:is-initialized ((self position))
  (cl:when (cl:/= (cl:logand (cl:slot-value self '%has-bits%)
                             #b00011)
                  #b00011)
    (cl:return-from pb:is-initialized cl:nil))
  cl:t)

(cl:defmethod pb:octet-size ((self position))
  (cl:let ((size 0))
    ;; required float latitude = 1[json_name = "latitude"];
    (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
      (cl:incf size
        (cl:+ 1 4)))
    ;; required float longitude = 2[json_name = "longitude"];
    (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
      (cl:incf size
        (cl:+ 1 4)))
    ;; optional float bearing = 3[json_name = "bearing"];
    (cl:when (cl:logbitp 2 (cl:slot-value self '%has-bits%))
      (cl:incf size
        (cl:+ 1 4)))
    ;; optional double odometer = 4[json_name = "odometer"];
    (cl:when (cl:logbitp 3 (cl:slot-value self '%has-bits%))
      (cl:incf size
        (cl:+ 1 8)))
    ;; optional float speed = 5[json_name = "speed"];
    (cl:when (cl:logbitp 4 (cl:slot-value self '%has-bits%))
      (cl:incf size
        (cl:+ 1 4)))
    (cl:setf (cl:slot-value self 'pb::%cached-size%) size)
    size))

(cl:defmethod pb:serialize ((self position) buffer index limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index index limit)
              (cl:ignorable buffer limit))
  ;; required float latitude = 1[json_name = "latitude"];
  (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 13))
    (cl:setf index (wire-format:write-single-float-carefully buffer index limit (cl:slot-value self 'latitude))))
  ;; required float longitude = 2[json_name = "longitude"];
  (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 21))
    (cl:setf index (wire-format:write-single-float-carefully buffer index limit (cl:slot-value self 'longitude))))
  ;; optional float bearing = 3[json_name = "bearing"];
  (cl:when (cl:logbitp 2 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 29))
    (cl:setf index (wire-format:write-single-float-carefully buffer index limit (cl:slot-value self 'bearing))))
  ;; optional double odometer = 4[json_name = "odometer"];
  (cl:when (cl:logbitp 3 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 33))
    (cl:setf index (wire-format:write-double-float-carefully buffer index limit (cl:slot-value self 'odometer))))
  ;; optional float speed = 5[json_name = "speed"];
  (cl:when (cl:logbitp 4 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 45))
    (cl:setf index (wire-format:write-single-float-carefully buffer index limit (cl:slot-value self 'speed))))
  ;// Extension range [1000, 2000)
  ;DO_(_extensions_.SerializeWithCachedSizes(
  ;    1000, 2000, *this, output));

  index)

(cl:defmethod pb:merge-from-array ((self position) buffer start limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index start limit))
  (cl:do ((index start index))
      ((cl:>= index limit) index)
    (cl:declare (cl:type com.google.base:vector-index index))
    (cl:multiple-value-bind (tag new-index)
        (varint:parse-uint32-carefully buffer index limit)
      (cl:setf index new-index)
      (cl:case tag
        ;; required float latitude = 1[json_name = "latitude"];
        ((13)
          (cl:multiple-value-bind (value new-index)
              (wire-format:read-single-float-carefully buffer index limit)
            (cl:setf (cl:slot-value self 'latitude) value)
            (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        ;; required float longitude = 2[json_name = "longitude"];
        ((21)
          (cl:multiple-value-bind (value new-index)
              (wire-format:read-single-float-carefully buffer index limit)
            (cl:setf (cl:slot-value self 'longitude) value)
            (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        ;; optional float bearing = 3[json_name = "bearing"];
        ((29)
          (cl:multiple-value-bind (value new-index)
              (wire-format:read-single-float-carefully buffer index limit)
            (cl:setf (cl:slot-value self 'bearing) value)
            (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        ;; optional double odometer = 4[json_name = "odometer"];
        ((33)
          (cl:multiple-value-bind (value new-index)
              (wire-format:read-double-float-carefully buffer index limit)
            (cl:setf (cl:slot-value self 'odometer) value)
            (cl:setf (cl:ldb (cl:byte 1 3) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        ;; optional float speed = 5[json_name = "speed"];
        ((45)
          (cl:multiple-value-bind (value new-index)
              (wire-format:read-single-float-carefully buffer index limit)
            (cl:setf (cl:slot-value self 'speed) value)
            (cl:setf (cl:ldb (cl:byte 1 4) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        (cl:t
          (cl:when (cl:= (cl:logand tag 7) 4)
            (cl:return-from pb:merge-from-array index))
          (cl:setf index (wire-format:skip-field buffer index limit tag)))))))

(cl:defmethod pb:merge-from-message ((self position) (from position))
  (cl:when (cl:logbitp 0 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'latitude) (cl:slot-value from 'latitude))
    (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))
  (cl:when (cl:logbitp 1 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'longitude) (cl:slot-value from 'longitude))
    (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1))
  (cl:when (cl:logbitp 2 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'bearing) (cl:slot-value from 'bearing))
    (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 1))
  (cl:when (cl:logbitp 3 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'odometer) (cl:slot-value from 'odometer))
    (cl:setf (cl:ldb (cl:byte 1 3) (cl:slot-value self '%has-bits%)) 1))
  (cl:when (cl:logbitp 4 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'speed) (cl:slot-value from 'speed))
    (cl:setf (cl:ldb (cl:byte 1 4) (cl:slot-value self '%has-bits%)) 1))
)


(cl:defclass trip-descriptor (pb:protocol-buffer)
  (
  (trip-id
   :accessor trip-id
   :initform (pb:string-field "")
   :type pb::%sf%)
  (route-id
   :accessor route-id
   :initform (pb:string-field "")
   :type pb::%sf%)
  (direction-id
   :accessor direction-id
   :initform 0
   :type (cl:unsigned-byte 32))
  (start-time
   :accessor start-time
   :initform (pb:string-field "")
   :type pb::%sf%)
  (start-date
   :accessor start-date
   :initform (pb:string-field "")
   :type pb::%sf%)
  (schedule-relationship
   :accessor schedule-relationship
   :initform transit-realtime::+trip-descriptor-schedule-relationship-scheduled+
   :type transit-realtime::trip-descriptor-schedule-relationship)
  (%has-bits%
   :accessor %has-bits%
   :initform 0
   :type (cl:unsigned-byte 6))
  (pb::%cached-size%
   :initform 0
   :type (cl:integer 0 #.(cl:1- cl:array-dimension-limit)))
  ))

(cl:export 'trip-descriptor)

(cl:export 'trip-id)


(cl:defmethod (cl:setf trip-id) :after (x (self trip-descriptor))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-trip-id)
  (cl:defgeneric has-trip-id (proto)))
(cl:defmethod has-trip-id ((self trip-descriptor))
  (cl:logbitp 0 (cl:slot-value self '%has-bits%)))
(cl:export 'has-trip-id)

(cl:unless (cl:fboundp 'clear-trip-id)
  (cl:defgeneric clear-trip-id (proto)))
(cl:defmethod clear-trip-id ((self trip-descriptor))
  (cl:setf (cl:slot-value self 'trip-id) (pb:string-field ""))
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-trip-id)

(cl:export 'route-id)


(cl:defmethod (cl:setf route-id) :after (x (self trip-descriptor))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-route-id)
  (cl:defgeneric has-route-id (proto)))
(cl:defmethod has-route-id ((self trip-descriptor))
  (cl:logbitp 1 (cl:slot-value self '%has-bits%)))
(cl:export 'has-route-id)

(cl:unless (cl:fboundp 'clear-route-id)
  (cl:defgeneric clear-route-id (proto)))
(cl:defmethod clear-route-id ((self trip-descriptor))
  (cl:setf (cl:slot-value self 'route-id) (pb:string-field ""))
  (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-route-id)

(cl:export 'direction-id)


(cl:defmethod (cl:setf direction-id) :after (x (self trip-descriptor))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-direction-id)
  (cl:defgeneric has-direction-id (proto)))
(cl:defmethod has-direction-id ((self trip-descriptor))
  (cl:logbitp 2 (cl:slot-value self '%has-bits%)))
(cl:export 'has-direction-id)

(cl:unless (cl:fboundp 'clear-direction-id)
  (cl:defgeneric clear-direction-id (proto)))
(cl:defmethod clear-direction-id ((self trip-descriptor))
  (cl:setf (cl:slot-value self 'direction-id) 0)
  (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-direction-id)

(cl:export 'start-time)


(cl:defmethod (cl:setf start-time) :after (x (self trip-descriptor))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 3) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-start-time)
  (cl:defgeneric has-start-time (proto)))
(cl:defmethod has-start-time ((self trip-descriptor))
  (cl:logbitp 3 (cl:slot-value self '%has-bits%)))
(cl:export 'has-start-time)

(cl:unless (cl:fboundp 'clear-start-time)
  (cl:defgeneric clear-start-time (proto)))
(cl:defmethod clear-start-time ((self trip-descriptor))
  (cl:setf (cl:slot-value self 'start-time) (pb:string-field ""))
  (cl:setf (cl:ldb (cl:byte 1 3) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-start-time)

(cl:export 'start-date)


(cl:defmethod (cl:setf start-date) :after (x (self trip-descriptor))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 4) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-start-date)
  (cl:defgeneric has-start-date (proto)))
(cl:defmethod has-start-date ((self trip-descriptor))
  (cl:logbitp 4 (cl:slot-value self '%has-bits%)))
(cl:export 'has-start-date)

(cl:unless (cl:fboundp 'clear-start-date)
  (cl:defgeneric clear-start-date (proto)))
(cl:defmethod clear-start-date ((self trip-descriptor))
  (cl:setf (cl:slot-value self 'start-date) (pb:string-field ""))
  (cl:setf (cl:ldb (cl:byte 1 4) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-start-date)

(cl:export 'schedule-relationship)


(cl:defmethod (cl:setf schedule-relationship) :after (x (self trip-descriptor))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 5) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-schedule-relationship)
  (cl:defgeneric has-schedule-relationship (proto)))
(cl:defmethod has-schedule-relationship ((self trip-descriptor))
  (cl:logbitp 5 (cl:slot-value self '%has-bits%)))
(cl:export 'has-schedule-relationship)

(cl:unless (cl:fboundp 'clear-schedule-relationship)
  (cl:defgeneric clear-schedule-relationship (proto)))
(cl:defmethod clear-schedule-relationship ((self trip-descriptor))
  (cl:setf (cl:slot-value self 'schedule-relationship) transit-realtime::+trip-descriptor-schedule-relationship-scheduled+)
  (cl:setf (cl:ldb (cl:byte 1 5) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-schedule-relationship)


(cl:defmethod cl:print-object ((self trip-descriptor) stream)
  (cl:pprint-logical-block (stream cl:nil)
    (cl:print-unreadable-object (self stream :type cl:t :identity cl:t)
      (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_trip-id: ~s" (trip-id self)))
      (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_route-id: ~s" (route-id self)))
      (cl:when (cl:logbitp 2 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_direction-id: ~s" (direction-id self)))
      (cl:when (cl:logbitp 3 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_start-time: ~s" (start-time self)))
      (cl:when (cl:logbitp 4 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_start-date: ~s" (start-date self)))
      (cl:when (cl:logbitp 5 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_schedule-relationship: ~s" (schedule-relationship self)))
      ))
  (cl:values))

(cl:defmethod pb:clear ((self trip-descriptor))
  (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'trip-id) (pb:string-field "")))
  (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'route-id) (pb:string-field "")))
  (cl:setf (cl:slot-value self 'direction-id) 0)
  (cl:when (cl:logbitp 3 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'start-time) (pb:string-field "")))
  (cl:when (cl:logbitp 4 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'start-date) (pb:string-field "")))
  (cl:setf (cl:slot-value self 'schedule-relationship) transit-realtime::+trip-descriptor-schedule-relationship-scheduled+)
  (cl:setf (cl:slot-value self '%has-bits%) 0)
  (cl:values))

(cl:defmethod pb:is-initialized ((self trip-descriptor))
  cl:t)

(cl:defmethod pb:octet-size ((self trip-descriptor))
  (cl:let ((size 0))
    ;; optional string trip_id = 1[json_name = "tripId"];
    (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
      (cl:incf size 1)
      (cl:incf size (cl:let ((s (pb::%utf8-string-length% (cl:slot-value self 'trip-id))))
        (cl:+ s (varint:length32 s)))))
    ;; optional string route_id = 5[json_name = "routeId"];
    (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
      (cl:incf size 1)
      (cl:incf size (cl:let ((s (pb::%utf8-string-length% (cl:slot-value self 'route-id))))
        (cl:+ s (varint:length32 s)))))
    ;; optional uint32 direction_id = 6[json_name = "directionId"];
    (cl:when (cl:logbitp 2 (cl:slot-value self '%has-bits%))
      (cl:incf size
        (cl:+ 1 (varint:length32 (cl:slot-value self 'direction-id)))))
    ;; optional string start_time = 2[json_name = "startTime"];
    (cl:when (cl:logbitp 3 (cl:slot-value self '%has-bits%))
      (cl:incf size 1)
      (cl:incf size (cl:let ((s (pb::%utf8-string-length% (cl:slot-value self 'start-time))))
        (cl:+ s (varint:length32 s)))))
    ;; optional string start_date = 3[json_name = "startDate"];
    (cl:when (cl:logbitp 4 (cl:slot-value self '%has-bits%))
      (cl:incf size 1)
      (cl:incf size (cl:let ((s (pb::%utf8-string-length% (cl:slot-value self 'start-date))))
        (cl:+ s (varint:length32 s)))))
    ;; optional .transit_realtime.TripDescriptor.ScheduleRelationship schedule_relationship = 4[json_name = "scheduleRelationship"];
    (cl:when (cl:logbitp 5 (cl:slot-value self '%has-bits%))
      (cl:incf size 1)
      (cl:incf size (varint:length64 (cl:ldb (cl:byte 64 0) (cl:slot-value self 'schedule-relationship)))))
    (cl:setf (cl:slot-value self 'pb::%cached-size%) size)
    size))

(cl:defmethod pb:serialize ((self trip-descriptor) buffer index limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index index limit)
              (cl:ignorable buffer limit))
  ;; optional string trip_id = 1[json_name = "tripId"];
  (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 10))
    (cl:setf index (wire-format:write-octets-carefully buffer index limit (cl:slot-value (cl:slot-value self 'trip-id) 'pb::%octets%))))
  ;; optional string start_time = 2[json_name = "startTime"];
  (cl:when (cl:logbitp 3 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 18))
    (cl:setf index (wire-format:write-octets-carefully buffer index limit (cl:slot-value (cl:slot-value self 'start-time) 'pb::%octets%))))
  ;; optional string start_date = 3[json_name = "startDate"];
  (cl:when (cl:logbitp 4 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 26))
    (cl:setf index (wire-format:write-octets-carefully buffer index limit (cl:slot-value (cl:slot-value self 'start-date) 'pb::%octets%))))
  ;; optional .transit_realtime.TripDescriptor.ScheduleRelationship schedule_relationship = 4[json_name = "scheduleRelationship"];
  (cl:when (cl:logbitp 5 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 32))
    (cl:setf index
     (varint:encode-uint64-carefully buffer index limit
      (cl:ldb (cl:byte 64 0) (cl:slot-value self 'schedule-relationship)))))
  ;; optional string route_id = 5[json_name = "routeId"];
  (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 42))
    (cl:setf index (wire-format:write-octets-carefully buffer index limit (cl:slot-value (cl:slot-value self 'route-id) 'pb::%octets%))))
  ;; optional uint32 direction_id = 6[json_name = "directionId"];
  (cl:when (cl:logbitp 2 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 48))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit (cl:slot-value self 'direction-id))))
  ;// Extension range [1000, 2000)
  ;DO_(_extensions_.SerializeWithCachedSizes(
  ;    1000, 2000, *this, output));

  index)

(cl:defmethod pb:merge-from-array ((self trip-descriptor) buffer start limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index start limit))
  (cl:do ((index start index))
      ((cl:>= index limit) index)
    (cl:declare (cl:type com.google.base:vector-index index))
    (cl:multiple-value-bind (tag new-index)
        (varint:parse-uint32-carefully buffer index limit)
      (cl:setf index new-index)
      (cl:case tag
        ;; optional string trip_id = 1[json_name = "tripId"];
        ((10)
          (cl:multiple-value-bind (value new-index)
              (wire-format:read-octets-carefully buffer index limit)
            (cl:setf (cl:slot-value self 'trip-id) (pb:string-field value))
            (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        ;; optional string start_time = 2[json_name = "startTime"];
        ((18)
          (cl:multiple-value-bind (value new-index)
              (wire-format:read-octets-carefully buffer index limit)
            (cl:setf (cl:slot-value self 'start-time) (pb:string-field value))
            (cl:setf (cl:ldb (cl:byte 1 3) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        ;; optional string start_date = 3[json_name = "startDate"];
        ((26)
          (cl:multiple-value-bind (value new-index)
              (wire-format:read-octets-carefully buffer index limit)
            (cl:setf (cl:slot-value self 'start-date) (pb:string-field value))
            (cl:setf (cl:ldb (cl:byte 1 4) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        ;; optional .transit_realtime.TripDescriptor.ScheduleRelationship schedule_relationship = 4[json_name = "scheduleRelationship"];
        ((32)
          (cl:multiple-value-bind (value new-index)
              (varint:parse-int32-carefully buffer index limit)
            ;; XXXXX: when valid, set field, else add to unknown fields
            (cl:setf (cl:slot-value self 'schedule-relationship) value)
            (cl:setf (cl:ldb (cl:byte 1 5) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        ;; optional string route_id = 5[json_name = "routeId"];
        ((42)
          (cl:multiple-value-bind (value new-index)
              (wire-format:read-octets-carefully buffer index limit)
            (cl:setf (cl:slot-value self 'route-id) (pb:string-field value))
            (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        ;; optional uint32 direction_id = 6[json_name = "directionId"];
        ((48)
          (cl:multiple-value-bind (value new-index)
              (varint:parse-uint32-carefully buffer index limit)
            (cl:setf (cl:slot-value self 'direction-id) value)
            (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        (cl:t
          (cl:when (cl:= (cl:logand tag 7) 4)
            (cl:return-from pb:merge-from-array index))
          (cl:setf index (wire-format:skip-field buffer index limit tag)))))))

(cl:defmethod pb:merge-from-message ((self trip-descriptor) (from trip-descriptor))
  (cl:when (cl:logbitp 0 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'trip-id) (cl:slot-value from 'trip-id))
    (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))
  (cl:when (cl:logbitp 1 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'route-id) (cl:slot-value from 'route-id))
    (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1))
  (cl:when (cl:logbitp 2 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'direction-id) (cl:slot-value from 'direction-id))
    (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 1))
  (cl:when (cl:logbitp 3 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'start-time) (cl:slot-value from 'start-time))
    (cl:setf (cl:ldb (cl:byte 1 3) (cl:slot-value self '%has-bits%)) 1))
  (cl:when (cl:logbitp 4 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'start-date) (cl:slot-value from 'start-date))
    (cl:setf (cl:ldb (cl:byte 1 4) (cl:slot-value self '%has-bits%)) 1))
  (cl:when (cl:logbitp 5 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'schedule-relationship) (cl:slot-value from 'schedule-relationship))
    (cl:setf (cl:ldb (cl:byte 1 5) (cl:slot-value self '%has-bits%)) 1))
)


(cl:defclass vehicle-descriptor (pb:protocol-buffer)
  (
  (id
   :accessor id
   :initform (pb:string-field "")
   :type pb::%sf%)
  (label
   :accessor label
   :initform (pb:string-field "")
   :type pb::%sf%)
  (license-plate
   :accessor license-plate
   :initform (pb:string-field "")
   :type pb::%sf%)
  (%has-bits%
   :accessor %has-bits%
   :initform 0
   :type (cl:unsigned-byte 3))
  (pb::%cached-size%
   :initform 0
   :type (cl:integer 0 #.(cl:1- cl:array-dimension-limit)))
  ))

(cl:export 'vehicle-descriptor)

(cl:export 'id)


(cl:defmethod (cl:setf id) :after (x (self vehicle-descriptor))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-id)
  (cl:defgeneric has-id (proto)))
(cl:defmethod has-id ((self vehicle-descriptor))
  (cl:logbitp 0 (cl:slot-value self '%has-bits%)))
(cl:export 'has-id)

(cl:unless (cl:fboundp 'clear-id)
  (cl:defgeneric clear-id (proto)))
(cl:defmethod clear-id ((self vehicle-descriptor))
  (cl:setf (cl:slot-value self 'id) (pb:string-field ""))
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-id)

(cl:export 'label)


(cl:defmethod (cl:setf label) :after (x (self vehicle-descriptor))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-label)
  (cl:defgeneric has-label (proto)))
(cl:defmethod has-label ((self vehicle-descriptor))
  (cl:logbitp 1 (cl:slot-value self '%has-bits%)))
(cl:export 'has-label)

(cl:unless (cl:fboundp 'clear-label)
  (cl:defgeneric clear-label (proto)))
(cl:defmethod clear-label ((self vehicle-descriptor))
  (cl:setf (cl:slot-value self 'label) (pb:string-field ""))
  (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-label)

(cl:export 'license-plate)


(cl:defmethod (cl:setf license-plate) :after (x (self vehicle-descriptor))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-license-plate)
  (cl:defgeneric has-license-plate (proto)))
(cl:defmethod has-license-plate ((self vehicle-descriptor))
  (cl:logbitp 2 (cl:slot-value self '%has-bits%)))
(cl:export 'has-license-plate)

(cl:unless (cl:fboundp 'clear-license-plate)
  (cl:defgeneric clear-license-plate (proto)))
(cl:defmethod clear-license-plate ((self vehicle-descriptor))
  (cl:setf (cl:slot-value self 'license-plate) (pb:string-field ""))
  (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-license-plate)


(cl:defmethod cl:print-object ((self vehicle-descriptor) stream)
  (cl:pprint-logical-block (stream cl:nil)
    (cl:print-unreadable-object (self stream :type cl:t :identity cl:t)
      (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_id: ~s" (id self)))
      (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_label: ~s" (label self)))
      (cl:when (cl:logbitp 2 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_license-plate: ~s" (license-plate self)))
      ))
  (cl:values))

(cl:defmethod pb:clear ((self vehicle-descriptor))
  (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'id) (pb:string-field "")))
  (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'label) (pb:string-field "")))
  (cl:when (cl:logbitp 2 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'license-plate) (pb:string-field "")))
  (cl:setf (cl:slot-value self '%has-bits%) 0)
  (cl:values))

(cl:defmethod pb:is-initialized ((self vehicle-descriptor))
  cl:t)

(cl:defmethod pb:octet-size ((self vehicle-descriptor))
  (cl:let ((size 0))
    ;; optional string id = 1[json_name = "id"];
    (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
      (cl:incf size 1)
      (cl:incf size (cl:let ((s (pb::%utf8-string-length% (cl:slot-value self 'id))))
        (cl:+ s (varint:length32 s)))))
    ;; optional string label = 2[json_name = "label"];
    (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
      (cl:incf size 1)
      (cl:incf size (cl:let ((s (pb::%utf8-string-length% (cl:slot-value self 'label))))
        (cl:+ s (varint:length32 s)))))
    ;; optional string license_plate = 3[json_name = "licensePlate"];
    (cl:when (cl:logbitp 2 (cl:slot-value self '%has-bits%))
      (cl:incf size 1)
      (cl:incf size (cl:let ((s (pb::%utf8-string-length% (cl:slot-value self 'license-plate))))
        (cl:+ s (varint:length32 s)))))
    (cl:setf (cl:slot-value self 'pb::%cached-size%) size)
    size))

(cl:defmethod pb:serialize ((self vehicle-descriptor) buffer index limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index index limit)
              (cl:ignorable buffer limit))
  ;; optional string id = 1[json_name = "id"];
  (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 10))
    (cl:setf index (wire-format:write-octets-carefully buffer index limit (cl:slot-value (cl:slot-value self 'id) 'pb::%octets%))))
  ;; optional string label = 2[json_name = "label"];
  (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 18))
    (cl:setf index (wire-format:write-octets-carefully buffer index limit (cl:slot-value (cl:slot-value self 'label) 'pb::%octets%))))
  ;; optional string license_plate = 3[json_name = "licensePlate"];
  (cl:when (cl:logbitp 2 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 26))
    (cl:setf index (wire-format:write-octets-carefully buffer index limit (cl:slot-value (cl:slot-value self 'license-plate) 'pb::%octets%))))
  ;// Extension range [1000, 2000)
  ;DO_(_extensions_.SerializeWithCachedSizes(
  ;    1000, 2000, *this, output));

  index)

(cl:defmethod pb:merge-from-array ((self vehicle-descriptor) buffer start limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index start limit))
  (cl:do ((index start index))
      ((cl:>= index limit) index)
    (cl:declare (cl:type com.google.base:vector-index index))
    (cl:multiple-value-bind (tag new-index)
        (varint:parse-uint32-carefully buffer index limit)
      (cl:setf index new-index)
      (cl:case tag
        ;; optional string id = 1[json_name = "id"];
        ((10)
          (cl:multiple-value-bind (value new-index)
              (wire-format:read-octets-carefully buffer index limit)
            (cl:setf (cl:slot-value self 'id) (pb:string-field value))
            (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        ;; optional string label = 2[json_name = "label"];
        ((18)
          (cl:multiple-value-bind (value new-index)
              (wire-format:read-octets-carefully buffer index limit)
            (cl:setf (cl:slot-value self 'label) (pb:string-field value))
            (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        ;; optional string license_plate = 3[json_name = "licensePlate"];
        ((26)
          (cl:multiple-value-bind (value new-index)
              (wire-format:read-octets-carefully buffer index limit)
            (cl:setf (cl:slot-value self 'license-plate) (pb:string-field value))
            (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        (cl:t
          (cl:when (cl:= (cl:logand tag 7) 4)
            (cl:return-from pb:merge-from-array index))
          (cl:setf index (wire-format:skip-field buffer index limit tag)))))))

(cl:defmethod pb:merge-from-message ((self vehicle-descriptor) (from vehicle-descriptor))
  (cl:when (cl:logbitp 0 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'id) (cl:slot-value from 'id))
    (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))
  (cl:when (cl:logbitp 1 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'label) (cl:slot-value from 'label))
    (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1))
  (cl:when (cl:logbitp 2 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'license-plate) (cl:slot-value from 'license-plate))
    (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 1))
)


(cl:defclass entity-selector (pb:protocol-buffer)
  (
  (agency-id
   :accessor agency-id
   :initform (pb:string-field "")
   :type pb::%sf%)
  (route-id
   :accessor route-id
   :initform (pb:string-field "")
   :type pb::%sf%)
  (route-type
   :accessor route-type
   :initform 0
   :type (cl:signed-byte 32))
  (trip
   :accessor trip
   :initform cl:nil
   :type (cl:or cl:null transit-realtime::trip-descriptor))
  (stop-id
   :accessor stop-id
   :initform (pb:string-field "")
   :type pb::%sf%)
  (%has-bits%
   :accessor %has-bits%
   :initform 0
   :type (cl:unsigned-byte 5))
  (pb::%cached-size%
   :initform 0
   :type (cl:integer 0 #.(cl:1- cl:array-dimension-limit)))
  ))

(cl:export 'entity-selector)

(cl:export 'agency-id)


(cl:defmethod (cl:setf agency-id) :after (x (self entity-selector))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-agency-id)
  (cl:defgeneric has-agency-id (proto)))
(cl:defmethod has-agency-id ((self entity-selector))
  (cl:logbitp 0 (cl:slot-value self '%has-bits%)))
(cl:export 'has-agency-id)

(cl:unless (cl:fboundp 'clear-agency-id)
  (cl:defgeneric clear-agency-id (proto)))
(cl:defmethod clear-agency-id ((self entity-selector))
  (cl:setf (cl:slot-value self 'agency-id) (pb:string-field ""))
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-agency-id)

(cl:export 'route-id)


(cl:defmethod (cl:setf route-id) :after (x (self entity-selector))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-route-id)
  (cl:defgeneric has-route-id (proto)))
(cl:defmethod has-route-id ((self entity-selector))
  (cl:logbitp 1 (cl:slot-value self '%has-bits%)))
(cl:export 'has-route-id)

(cl:unless (cl:fboundp 'clear-route-id)
  (cl:defgeneric clear-route-id (proto)))
(cl:defmethod clear-route-id ((self entity-selector))
  (cl:setf (cl:slot-value self 'route-id) (pb:string-field ""))
  (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-route-id)

(cl:export 'route-type)


(cl:defmethod (cl:setf route-type) :after (x (self entity-selector))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-route-type)
  (cl:defgeneric has-route-type (proto)))
(cl:defmethod has-route-type ((self entity-selector))
  (cl:logbitp 2 (cl:slot-value self '%has-bits%)))
(cl:export 'has-route-type)

(cl:unless (cl:fboundp 'clear-route-type)
  (cl:defgeneric clear-route-type (proto)))
(cl:defmethod clear-route-type ((self entity-selector))
  (cl:setf (cl:slot-value self 'route-type) 0)
  (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-route-type)

(cl:export 'trip)


(cl:defmethod (cl:setf trip) :after (x (self entity-selector))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 3) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-trip)
  (cl:defgeneric has-trip (proto)))
(cl:defmethod has-trip ((self entity-selector))
  (cl:logbitp 3 (cl:slot-value self '%has-bits%)))
(cl:export 'has-trip)

(cl:unless (cl:fboundp 'clear-trip)
  (cl:defgeneric clear-trip (proto)))
(cl:defmethod clear-trip ((self entity-selector))
  (cl:setf (cl:slot-value self 'trip) cl:nil)
  (cl:setf (cl:ldb (cl:byte 1 3) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-trip)

(cl:export 'stop-id)


(cl:defmethod (cl:setf stop-id) :after (x (self entity-selector))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 4) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-stop-id)
  (cl:defgeneric has-stop-id (proto)))
(cl:defmethod has-stop-id ((self entity-selector))
  (cl:logbitp 4 (cl:slot-value self '%has-bits%)))
(cl:export 'has-stop-id)

(cl:unless (cl:fboundp 'clear-stop-id)
  (cl:defgeneric clear-stop-id (proto)))
(cl:defmethod clear-stop-id ((self entity-selector))
  (cl:setf (cl:slot-value self 'stop-id) (pb:string-field ""))
  (cl:setf (cl:ldb (cl:byte 1 4) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-stop-id)


(cl:defmethod cl:print-object ((self entity-selector) stream)
  (cl:pprint-logical-block (stream cl:nil)
    (cl:print-unreadable-object (self stream :type cl:t :identity cl:t)
      (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_agency-id: ~s" (agency-id self)))
      (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_route-id: ~s" (route-id self)))
      (cl:when (cl:logbitp 2 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_route-type: ~s" (route-type self)))
      (cl:when (cl:logbitp 3 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_trip: ~s" (trip self)))
      (cl:when (cl:logbitp 4 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_stop-id: ~s" (stop-id self)))
      ))
  (cl:values))

(cl:defmethod pb:clear ((self entity-selector))
  (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'agency-id) (pb:string-field "")))
  (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'route-id) (pb:string-field "")))
  (cl:setf (cl:slot-value self 'route-type) 0)
  (cl:when (cl:logbitp 3 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'trip) cl:nil))
  (cl:when (cl:logbitp 4 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'stop-id) (pb:string-field "")))
  (cl:setf (cl:slot-value self '%has-bits%) 0)
  (cl:values))

(cl:defmethod pb:is-initialized ((self entity-selector))
  (cl:when (cl:logbitp 3 (cl:slot-value self '%has-bits%))
    (cl:unless (pb:is-initialized (cl:slot-value self 'trip))
      (cl:return-from pb:is-initialized cl:nil)))
  cl:t)

(cl:defmethod pb:octet-size ((self entity-selector))
  (cl:let ((size 0))
    ;; optional string agency_id = 1[json_name = "agencyId"];
    (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
      (cl:incf size 1)
      (cl:incf size (cl:let ((s (pb::%utf8-string-length% (cl:slot-value self 'agency-id))))
        (cl:+ s (varint:length32 s)))))
    ;; optional string route_id = 2[json_name = "routeId"];
    (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
      (cl:incf size 1)
      (cl:incf size (cl:let ((s (pb::%utf8-string-length% (cl:slot-value self 'route-id))))
        (cl:+ s (varint:length32 s)))))
    ;; optional int32 route_type = 3[json_name = "routeType"];
    (cl:when (cl:logbitp 2 (cl:slot-value self '%has-bits%))
      (cl:incf size
        (cl:+ 1 (varint:length64 (cl:ldb (cl:byte 64 0) (cl:slot-value self 'route-type))))))
    ;; optional .transit_realtime.TripDescriptor trip = 4[json_name = "trip"];
    (cl:when (cl:logbitp 3 (cl:slot-value self '%has-bits%))
      (cl:let ((s (pb:octet-size (cl:slot-value self 'trip))))
        (cl:incf size (cl:+ 1 s (varint:length32 s)))))
    ;; optional string stop_id = 5[json_name = "stopId"];
    (cl:when (cl:logbitp 4 (cl:slot-value self '%has-bits%))
      (cl:incf size 1)
      (cl:incf size (cl:let ((s (pb::%utf8-string-length% (cl:slot-value self 'stop-id))))
        (cl:+ s (varint:length32 s)))))
    (cl:setf (cl:slot-value self 'pb::%cached-size%) size)
    size))

(cl:defmethod pb:serialize ((self entity-selector) buffer index limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index index limit)
              (cl:ignorable buffer limit))
  ;; optional string agency_id = 1[json_name = "agencyId"];
  (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 10))
    (cl:setf index (wire-format:write-octets-carefully buffer index limit (cl:slot-value (cl:slot-value self 'agency-id) 'pb::%octets%))))
  ;; optional string route_id = 2[json_name = "routeId"];
  (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 18))
    (cl:setf index (wire-format:write-octets-carefully buffer index limit (cl:slot-value (cl:slot-value self 'route-id) 'pb::%octets%))))
  ;; optional int32 route_type = 3[json_name = "routeType"];
  (cl:when (cl:logbitp 2 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 24))
    (cl:setf index (varint:encode-uint64-carefully buffer index limit (cl:ldb (cl:byte 64 0) (cl:slot-value self 'route-type)))))
  ;; optional .transit_realtime.TripDescriptor trip = 4[json_name = "trip"];
  (cl:when (cl:logbitp 3 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 34))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit (cl:slot-value (cl:slot-value self 'trip) 'pb::%cached-size%)))
    (cl:setf index (pb:serialize (cl:slot-value self 'trip) buffer index limit)))
  ;; optional string stop_id = 5[json_name = "stopId"];
  (cl:when (cl:logbitp 4 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 42))
    (cl:setf index (wire-format:write-octets-carefully buffer index limit (cl:slot-value (cl:slot-value self 'stop-id) 'pb::%octets%))))
  ;// Extension range [1000, 2000)
  ;DO_(_extensions_.SerializeWithCachedSizes(
  ;    1000, 2000, *this, output));

  index)

(cl:defmethod pb:merge-from-array ((self entity-selector) buffer start limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index start limit))
  (cl:do ((index start index))
      ((cl:>= index limit) index)
    (cl:declare (cl:type com.google.base:vector-index index))
    (cl:multiple-value-bind (tag new-index)
        (varint:parse-uint32-carefully buffer index limit)
      (cl:setf index new-index)
      (cl:case tag
        ;; optional string agency_id = 1[json_name = "agencyId"];
        ((10)
          (cl:multiple-value-bind (value new-index)
              (wire-format:read-octets-carefully buffer index limit)
            (cl:setf (cl:slot-value self 'agency-id) (pb:string-field value))
            (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        ;; optional string route_id = 2[json_name = "routeId"];
        ((18)
          (cl:multiple-value-bind (value new-index)
              (wire-format:read-octets-carefully buffer index limit)
            (cl:setf (cl:slot-value self 'route-id) (pb:string-field value))
            (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        ;; optional int32 route_type = 3[json_name = "routeType"];
        ((24)
          (cl:multiple-value-bind (value new-index)
              (varint:parse-int32-carefully buffer index limit)
            (cl:setf (cl:slot-value self 'route-type) value)
            (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        ;; optional .transit_realtime.TripDescriptor trip = 4[json_name = "trip"];
        ((34)
          (cl:multiple-value-bind (length new-index)
              (varint:parse-uint31-carefully buffer index limit)
            (cl:when (cl:> (cl:+ new-index length) limit)
              (cl:error "buffer overflow"))
            (cl:let ((message (cl:slot-value self 'trip)))
              (cl:when (cl:null message)
                (cl:setf message (cl:make-instance 'transit-realtime::trip-descriptor))
                (cl:setf (cl:slot-value self 'trip) message)
                (cl:setf (cl:ldb (cl:byte 1 3) (cl:slot-value self '%has-bits%)) 1))
              (cl:setf index (pb:merge-from-array message buffer new-index (cl:+ new-index length)))
              (cl:when (cl:not (cl:= index (cl:+ new-index length)))
                (cl:error "buffer overflow")))))
        ;; optional string stop_id = 5[json_name = "stopId"];
        ((42)
          (cl:multiple-value-bind (value new-index)
              (wire-format:read-octets-carefully buffer index limit)
            (cl:setf (cl:slot-value self 'stop-id) (pb:string-field value))
            (cl:setf (cl:ldb (cl:byte 1 4) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        (cl:t
          (cl:when (cl:= (cl:logand tag 7) 4)
            (cl:return-from pb:merge-from-array index))
          (cl:setf index (wire-format:skip-field buffer index limit tag)))))))

(cl:defmethod pb:merge-from-message ((self entity-selector) (from entity-selector))
  (cl:when (cl:logbitp 0 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'agency-id) (cl:slot-value from 'agency-id))
    (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))
  (cl:when (cl:logbitp 1 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'route-id) (cl:slot-value from 'route-id))
    (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1))
  (cl:when (cl:logbitp 2 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'route-type) (cl:slot-value from 'route-type))
    (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 1))
  (cl:when (cl:logbitp 3 (cl:slot-value from '%has-bits%))
    (cl:let ((message (cl:slot-value self 'trip)))
      (cl:when (cl:null message)
        (cl:setf message (cl:make-instance 'transit-realtime::trip-descriptor))
        (cl:setf (cl:slot-value self 'trip) message)
        (cl:setf (cl:ldb (cl:byte 1 3) (cl:slot-value self '%has-bits%)) 1))
     (pb:merge-from-message message (cl:slot-value from 'trip))))
  (cl:when (cl:logbitp 4 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'stop-id) (cl:slot-value from 'stop-id))
    (cl:setf (cl:ldb (cl:byte 1 4) (cl:slot-value self '%has-bits%)) 1))
)


(cl:defclass translated-string-translation (pb:protocol-buffer)
  (
  (text
   :accessor text
   :initform (pb:string-field "")
   :type pb::%sf%)
  (language
   :accessor language
   :initform (pb:string-field "")
   :type pb::%sf%)
  (%has-bits%
   :accessor %has-bits%
   :initform 0
   :type (cl:unsigned-byte 2))
  (pb::%cached-size%
   :initform 0
   :type (cl:integer 0 #.(cl:1- cl:array-dimension-limit)))
  ))

(cl:export 'translated-string-translation)

(cl:export 'text)


(cl:defmethod (cl:setf text) :after (x (self translated-string-translation))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-text)
  (cl:defgeneric has-text (proto)))
(cl:defmethod has-text ((self translated-string-translation))
  (cl:logbitp 0 (cl:slot-value self '%has-bits%)))
(cl:export 'has-text)

(cl:unless (cl:fboundp 'clear-text)
  (cl:defgeneric clear-text (proto)))
(cl:defmethod clear-text ((self translated-string-translation))
  (cl:setf (cl:slot-value self 'text) (pb:string-field ""))
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-text)

(cl:export 'language)


(cl:defmethod (cl:setf language) :after (x (self translated-string-translation))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-language)
  (cl:defgeneric has-language (proto)))
(cl:defmethod has-language ((self translated-string-translation))
  (cl:logbitp 1 (cl:slot-value self '%has-bits%)))
(cl:export 'has-language)

(cl:unless (cl:fboundp 'clear-language)
  (cl:defgeneric clear-language (proto)))
(cl:defmethod clear-language ((self translated-string-translation))
  (cl:setf (cl:slot-value self 'language) (pb:string-field ""))
  (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-language)



(cl:defclass translated-string (pb:protocol-buffer)
  (
  (translation
   :accessor translation
   :initform (cl:make-array
              0
              :element-type 'transit-realtime::translated-string-translation
              :fill-pointer 0 :adjustable cl:t)
   :type (cl:vector transit-realtime::translated-string-translation))
  (%has-bits%
   :accessor %has-bits%
   :initform 0
   :type (cl:unsigned-byte 1))
  (pb::%cached-size%
   :initform 0
   :type (cl:integer 0 #.(cl:1- cl:array-dimension-limit)))
  ))

(cl:export 'translated-string)

(cl:export 'translation)

(cl:unless (cl:fboundp 'clear-translation)
  (cl:defgeneric clear-translation (proto)))
(cl:defmethod clear-translation ((self translated-string))
  (cl:setf (cl:slot-value self 'translation)
           (cl:make-array 0 :element-type 'transit-realtime::translated-string-translation
            :fill-pointer 0 :adjustable cl:t))
  (cl:values))
(cl:export 'clear-translation)


(cl:defmethod cl:print-object ((self translated-string-translation) stream)
  (cl:pprint-logical-block (stream cl:nil)
    (cl:print-unreadable-object (self stream :type cl:t :identity cl:t)
      (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_text: ~s" (text self)))
      (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_language: ~s" (language self)))
      ))
  (cl:values))

(cl:defmethod pb:clear ((self translated-string-translation))
  (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'text) (pb:string-field "")))
  (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'language) (pb:string-field "")))
  (cl:setf (cl:slot-value self '%has-bits%) 0)
  (cl:values))

(cl:defmethod pb:is-initialized ((self translated-string-translation))
  (cl:when (cl:/= (cl:logand (cl:slot-value self '%has-bits%)
                             #b01)
                  #b01)
    (cl:return-from pb:is-initialized cl:nil))
  cl:t)

(cl:defmethod pb:octet-size ((self translated-string-translation))
  (cl:let ((size 0))
    ;; required string text = 1[json_name = "text"];
    (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
      (cl:incf size 1)
      (cl:incf size (cl:let ((s (pb::%utf8-string-length% (cl:slot-value self 'text))))
        (cl:+ s (varint:length32 s)))))
    ;; optional string language = 2[json_name = "language"];
    (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
      (cl:incf size 1)
      (cl:incf size (cl:let ((s (pb::%utf8-string-length% (cl:slot-value self 'language))))
        (cl:+ s (varint:length32 s)))))
    (cl:setf (cl:slot-value self 'pb::%cached-size%) size)
    size))

(cl:defmethod pb:serialize ((self translated-string-translation) buffer index limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index index limit)
              (cl:ignorable buffer limit))
  ;; required string text = 1[json_name = "text"];
  (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 10))
    (cl:setf index (wire-format:write-octets-carefully buffer index limit (cl:slot-value (cl:slot-value self 'text) 'pb::%octets%))))
  ;; optional string language = 2[json_name = "language"];
  (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 18))
    (cl:setf index (wire-format:write-octets-carefully buffer index limit (cl:slot-value (cl:slot-value self 'language) 'pb::%octets%))))
  ;// Extension range [1000, 2000)
  ;DO_(_extensions_.SerializeWithCachedSizes(
  ;    1000, 2000, *this, output));

  index)

(cl:defmethod pb:merge-from-array ((self translated-string-translation) buffer start limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index start limit))
  (cl:do ((index start index))
      ((cl:>= index limit) index)
    (cl:declare (cl:type com.google.base:vector-index index))
    (cl:multiple-value-bind (tag new-index)
        (varint:parse-uint32-carefully buffer index limit)
      (cl:setf index new-index)
      (cl:case tag
        ;; required string text = 1[json_name = "text"];
        ((10)
          (cl:multiple-value-bind (value new-index)
              (wire-format:read-octets-carefully buffer index limit)
            (cl:setf (cl:slot-value self 'text) (pb:string-field value))
            (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        ;; optional string language = 2[json_name = "language"];
        ((18)
          (cl:multiple-value-bind (value new-index)
              (wire-format:read-octets-carefully buffer index limit)
            (cl:setf (cl:slot-value self 'language) (pb:string-field value))
            (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        (cl:t
          (cl:when (cl:= (cl:logand tag 7) 4)
            (cl:return-from pb:merge-from-array index))
          (cl:setf index (wire-format:skip-field buffer index limit tag)))))))

(cl:defmethod pb:merge-from-message ((self translated-string-translation) (from translated-string-translation))
  (cl:when (cl:logbitp 0 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'text) (cl:slot-value from 'text))
    (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))
  (cl:when (cl:logbitp 1 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'language) (cl:slot-value from 'language))
    (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1))
)



(cl:defmethod cl:print-object ((self translated-string) stream)
  (cl:pprint-logical-block (stream cl:nil)
    (cl:print-unreadable-object (self stream :type cl:t :identity cl:t)
      (cl:format stream " ~_translation: ~s" (translation self))
      ))
  (cl:values))

(cl:defmethod pb:clear ((self translated-string))
  (cl:setf (cl:slot-value self 'translation)
           (cl:make-array 0 :element-type 'transit-realtime::translated-string-translation
            :fill-pointer 0 :adjustable cl:t))
  (cl:setf (cl:slot-value self '%has-bits%) 0)
  (cl:values))

(cl:defmethod pb:is-initialized ((self translated-string))
  (cl:let* ((x (cl:slot-value self 'translation))
            (length (cl:length x)))
    (cl:dotimes (i length)
      (cl:unless (pb:is-initialized (cl:aref x i))
        (cl:return-from pb:is-initialized cl:nil))))
  cl:t)

(cl:defmethod pb:octet-size ((self translated-string))
  (cl:let ((size 0))
    ;; repeated .transit_realtime.TranslatedString.Translation translation = 1[json_name = "translation"];
    (cl:let* ((v (cl:slot-value self 'translation))
              (length (cl:length v)))
      (cl:incf size (cl:* 1 length))
      (cl:dotimes (i length)
        (cl:let ((s (pb:octet-size (cl:aref v i))))
          (cl:incf size (cl:+ s (varint:length32 s))))))
    (cl:setf (cl:slot-value self 'pb::%cached-size%) size)
    size))

(cl:defmethod pb:serialize ((self translated-string) buffer index limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index index limit)
              (cl:ignorable buffer limit))
  ;; repeated .transit_realtime.TranslatedString.Translation translation = 1[json_name = "translation"];
  (cl:let* ((v (cl:slot-value self 'translation))
            (length (cl:length v)))
    (cl:loop for i from 0 below length do
       (cl:setf index (varint:encode-uint32-carefully buffer index limit 10))
       (cl:setf index (varint:encode-uint32-carefully buffer index limit (cl:slot-value (cl:aref v i) 'pb::%cached-size%)))
       (cl:setf index (pb:serialize (cl:aref v i) buffer index limit))))
  ;// Extension range [1000, 2000)
  ;DO_(_extensions_.SerializeWithCachedSizes(
  ;    1000, 2000, *this, output));

  index)

(cl:defmethod pb:merge-from-array ((self translated-string) buffer start limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index start limit))
  (cl:do ((index start index))
      ((cl:>= index limit) index)
    (cl:declare (cl:type com.google.base:vector-index index))
    (cl:multiple-value-bind (tag new-index)
        (varint:parse-uint32-carefully buffer index limit)
      (cl:setf index new-index)
      (cl:case tag
        ;; repeated .transit_realtime.TranslatedString.Translation translation = 1[json_name = "translation"];
        ((10)
          (cl:multiple-value-bind (length new-index)
              (varint:parse-uint31-carefully buffer index limit)
            (cl:when (cl:> (cl:+ new-index length) limit)
              (cl:error "buffer overflow"))
            (cl:let ((message (cl:make-instance 'transit-realtime::translated-string-translation)))
              (cl:setf index (pb:merge-from-array message buffer new-index (cl:+ new-index length)))
              (cl:when (cl:not (cl:= index (cl:+ new-index length)))
                (cl:error "buffer overflow"))
              (cl:vector-push-extend message (cl:slot-value self 'translation)))))
        (cl:t
          (cl:when (cl:= (cl:logand tag 7) 4)
            (cl:return-from pb:merge-from-array index))
          (cl:setf index (wire-format:skip-field buffer index limit tag)))))))

(cl:defmethod pb:merge-from-message ((self translated-string) (from translated-string))
  (cl:let* ((v (cl:slot-value self 'translation))
            (vf (cl:slot-value from 'translation))
            (length (cl:length vf)))
    (cl:loop for i from 0 below length do
      (cl:vector-push-extend (cl:aref vf i) v)))
)


(cl:defclass tfnsw-vehicle-descriptor (pb:protocol-buffer)
  (
  (air-conditioned
   :accessor air-conditioned
   :initform cl:nil
   :type cl:boolean)
  (wheelchair-accessible
   :accessor wheelchair-accessible
   :initform 0
   :type (cl:signed-byte 32))
  (vehicle-model
   :accessor vehicle-model
   :initform (pb:string-field "")
   :type pb::%sf%)
  (performing-prior-trip
   :accessor performing-prior-trip
   :initform cl:nil
   :type cl:boolean)
  (special-vehicle-attributes
   :accessor special-vehicle-attributes
   :initform 0
   :type (cl:signed-byte 32))
  (%has-bits%
   :accessor %has-bits%
   :initform 0
   :type (cl:unsigned-byte 5))
  (pb::%cached-size%
   :initform 0
   :type (cl:integer 0 #.(cl:1- cl:array-dimension-limit)))
  ))

(cl:export 'tfnsw-vehicle-descriptor)

(cl:export 'air-conditioned)


(cl:defmethod (cl:setf air-conditioned) :after (x (self tfnsw-vehicle-descriptor))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-air-conditioned)
  (cl:defgeneric has-air-conditioned (proto)))
(cl:defmethod has-air-conditioned ((self tfnsw-vehicle-descriptor))
  (cl:logbitp 0 (cl:slot-value self '%has-bits%)))
(cl:export 'has-air-conditioned)

(cl:unless (cl:fboundp 'clear-air-conditioned)
  (cl:defgeneric clear-air-conditioned (proto)))
(cl:defmethod clear-air-conditioned ((self tfnsw-vehicle-descriptor))
  (cl:setf (cl:slot-value self 'air-conditioned) cl:nil)
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-air-conditioned)

(cl:export 'wheelchair-accessible)


(cl:defmethod (cl:setf wheelchair-accessible) :after (x (self tfnsw-vehicle-descriptor))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-wheelchair-accessible)
  (cl:defgeneric has-wheelchair-accessible (proto)))
(cl:defmethod has-wheelchair-accessible ((self tfnsw-vehicle-descriptor))
  (cl:logbitp 1 (cl:slot-value self '%has-bits%)))
(cl:export 'has-wheelchair-accessible)

(cl:unless (cl:fboundp 'clear-wheelchair-accessible)
  (cl:defgeneric clear-wheelchair-accessible (proto)))
(cl:defmethod clear-wheelchair-accessible ((self tfnsw-vehicle-descriptor))
  (cl:setf (cl:slot-value self 'wheelchair-accessible) 0)
  (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-wheelchair-accessible)

(cl:export 'vehicle-model)


(cl:defmethod (cl:setf vehicle-model) :after (x (self tfnsw-vehicle-descriptor))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-vehicle-model)
  (cl:defgeneric has-vehicle-model (proto)))
(cl:defmethod has-vehicle-model ((self tfnsw-vehicle-descriptor))
  (cl:logbitp 2 (cl:slot-value self '%has-bits%)))
(cl:export 'has-vehicle-model)

(cl:unless (cl:fboundp 'clear-vehicle-model)
  (cl:defgeneric clear-vehicle-model (proto)))
(cl:defmethod clear-vehicle-model ((self tfnsw-vehicle-descriptor))
  (cl:setf (cl:slot-value self 'vehicle-model) (pb:string-field ""))
  (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-vehicle-model)

(cl:export 'performing-prior-trip)


(cl:defmethod (cl:setf performing-prior-trip) :after (x (self tfnsw-vehicle-descriptor))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 3) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-performing-prior-trip)
  (cl:defgeneric has-performing-prior-trip (proto)))
(cl:defmethod has-performing-prior-trip ((self tfnsw-vehicle-descriptor))
  (cl:logbitp 3 (cl:slot-value self '%has-bits%)))
(cl:export 'has-performing-prior-trip)

(cl:unless (cl:fboundp 'clear-performing-prior-trip)
  (cl:defgeneric clear-performing-prior-trip (proto)))
(cl:defmethod clear-performing-prior-trip ((self tfnsw-vehicle-descriptor))
  (cl:setf (cl:slot-value self 'performing-prior-trip) cl:nil)
  (cl:setf (cl:ldb (cl:byte 1 3) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-performing-prior-trip)

(cl:export 'special-vehicle-attributes)


(cl:defmethod (cl:setf special-vehicle-attributes) :after (x (self tfnsw-vehicle-descriptor))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 4) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-special-vehicle-attributes)
  (cl:defgeneric has-special-vehicle-attributes (proto)))
(cl:defmethod has-special-vehicle-attributes ((self tfnsw-vehicle-descriptor))
  (cl:logbitp 4 (cl:slot-value self '%has-bits%)))
(cl:export 'has-special-vehicle-attributes)

(cl:unless (cl:fboundp 'clear-special-vehicle-attributes)
  (cl:defgeneric clear-special-vehicle-attributes (proto)))
(cl:defmethod clear-special-vehicle-attributes ((self tfnsw-vehicle-descriptor))
  (cl:setf (cl:slot-value self 'special-vehicle-attributes) 0)
  (cl:setf (cl:ldb (cl:byte 1 4) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-special-vehicle-attributes)


(cl:defmethod cl:print-object ((self tfnsw-vehicle-descriptor) stream)
  (cl:pprint-logical-block (stream cl:nil)
    (cl:print-unreadable-object (self stream :type cl:t :identity cl:t)
      (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_air-conditioned: ~s" (air-conditioned self)))
      (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_wheelchair-accessible: ~s" (wheelchair-accessible self)))
      (cl:when (cl:logbitp 2 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_vehicle-model: ~s" (vehicle-model self)))
      (cl:when (cl:logbitp 3 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_performing-prior-trip: ~s" (performing-prior-trip self)))
      (cl:when (cl:logbitp 4 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_special-vehicle-attributes: ~s" (special-vehicle-attributes self)))
      ))
  (cl:values))

(cl:defmethod pb:clear ((self tfnsw-vehicle-descriptor))
  (cl:setf (cl:slot-value self 'air-conditioned) cl:nil)
  (cl:setf (cl:slot-value self 'wheelchair-accessible) 0)
  (cl:when (cl:logbitp 2 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'vehicle-model) (pb:string-field "")))
  (cl:setf (cl:slot-value self 'performing-prior-trip) cl:nil)
  (cl:setf (cl:slot-value self 'special-vehicle-attributes) 0)
  (cl:setf (cl:slot-value self '%has-bits%) 0)
  (cl:values))

(cl:defmethod pb:is-initialized ((self tfnsw-vehicle-descriptor))
  cl:t)

(cl:defmethod pb:octet-size ((self tfnsw-vehicle-descriptor))
  (cl:let ((size 0))
    ;; optional bool air_conditioned = 1 [default = false, json_name = "airConditioned"];
    (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
      (cl:incf size
        (cl:+ 1 1)))
    ;; optional int32 wheelchair_accessible = 2 [default = 0, json_name = "wheelchairAccessible"];
    (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
      (cl:incf size
        (cl:+ 1 (varint:length64 (cl:ldb (cl:byte 64 0) (cl:slot-value self 'wheelchair-accessible))))))
    ;; optional string vehicle_model = 3[json_name = "vehicleModel"];
    (cl:when (cl:logbitp 2 (cl:slot-value self '%has-bits%))
      (cl:incf size 1)
      (cl:incf size (cl:let ((s (pb::%utf8-string-length% (cl:slot-value self 'vehicle-model))))
        (cl:+ s (varint:length32 s)))))
    ;; optional bool performing_prior_trip = 4 [default = false, json_name = "performingPriorTrip"];
    (cl:when (cl:logbitp 3 (cl:slot-value self '%has-bits%))
      (cl:incf size
        (cl:+ 1 1)))
    ;; optional int32 special_vehicle_attributes = 5 [default = 0, json_name = "specialVehicleAttributes"];
    (cl:when (cl:logbitp 4 (cl:slot-value self '%has-bits%))
      (cl:incf size
        (cl:+ 1 (varint:length64 (cl:ldb (cl:byte 64 0) (cl:slot-value self 'special-vehicle-attributes))))))
    (cl:setf (cl:slot-value self 'pb::%cached-size%) size)
    size))

(cl:defmethod pb:serialize ((self tfnsw-vehicle-descriptor) buffer index limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index index limit)
              (cl:ignorable buffer limit))
  ;; optional bool air_conditioned = 1 [default = false, json_name = "airConditioned"];
  (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 8))
    (cl:setf index (wire-format:write-boolean-carefully buffer index limit (cl:slot-value self 'air-conditioned))))
  ;; optional int32 wheelchair_accessible = 2 [default = 0, json_name = "wheelchairAccessible"];
  (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 16))
    (cl:setf index (varint:encode-uint64-carefully buffer index limit (cl:ldb (cl:byte 64 0) (cl:slot-value self 'wheelchair-accessible)))))
  ;; optional string vehicle_model = 3[json_name = "vehicleModel"];
  (cl:when (cl:logbitp 2 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 26))
    (cl:setf index (wire-format:write-octets-carefully buffer index limit (cl:slot-value (cl:slot-value self 'vehicle-model) 'pb::%octets%))))
  ;; optional bool performing_prior_trip = 4 [default = false, json_name = "performingPriorTrip"];
  (cl:when (cl:logbitp 3 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 32))
    (cl:setf index (wire-format:write-boolean-carefully buffer index limit (cl:slot-value self 'performing-prior-trip))))
  ;; optional int32 special_vehicle_attributes = 5 [default = 0, json_name = "specialVehicleAttributes"];
  (cl:when (cl:logbitp 4 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 40))
    (cl:setf index (varint:encode-uint64-carefully buffer index limit (cl:ldb (cl:byte 64 0) (cl:slot-value self 'special-vehicle-attributes)))))
  index)

(cl:defmethod pb:merge-from-array ((self tfnsw-vehicle-descriptor) buffer start limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index start limit))
  (cl:do ((index start index))
      ((cl:>= index limit) index)
    (cl:declare (cl:type com.google.base:vector-index index))
    (cl:multiple-value-bind (tag new-index)
        (varint:parse-uint32-carefully buffer index limit)
      (cl:setf index new-index)
      (cl:case tag
        ;; optional bool air_conditioned = 1 [default = false, json_name = "airConditioned"];
        ((8)
          (cl:multiple-value-bind (value new-index)
              (wire-format:read-boolean-carefully buffer index limit)
            (cl:setf (cl:slot-value self 'air-conditioned) value)
            (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        ;; optional int32 wheelchair_accessible = 2 [default = 0, json_name = "wheelchairAccessible"];
        ((16)
          (cl:multiple-value-bind (value new-index)
              (varint:parse-int32-carefully buffer index limit)
            (cl:setf (cl:slot-value self 'wheelchair-accessible) value)
            (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        ;; optional string vehicle_model = 3[json_name = "vehicleModel"];
        ((26)
          (cl:multiple-value-bind (value new-index)
              (wire-format:read-octets-carefully buffer index limit)
            (cl:setf (cl:slot-value self 'vehicle-model) (pb:string-field value))
            (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        ;; optional bool performing_prior_trip = 4 [default = false, json_name = "performingPriorTrip"];
        ((32)
          (cl:multiple-value-bind (value new-index)
              (wire-format:read-boolean-carefully buffer index limit)
            (cl:setf (cl:slot-value self 'performing-prior-trip) value)
            (cl:setf (cl:ldb (cl:byte 1 3) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        ;; optional int32 special_vehicle_attributes = 5 [default = 0, json_name = "specialVehicleAttributes"];
        ((40)
          (cl:multiple-value-bind (value new-index)
              (varint:parse-int32-carefully buffer index limit)
            (cl:setf (cl:slot-value self 'special-vehicle-attributes) value)
            (cl:setf (cl:ldb (cl:byte 1 4) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        (cl:t
          (cl:when (cl:= (cl:logand tag 7) 4)
            (cl:return-from pb:merge-from-array index))
          (cl:setf index (wire-format:skip-field buffer index limit tag)))))))

(cl:defmethod pb:merge-from-message ((self tfnsw-vehicle-descriptor) (from tfnsw-vehicle-descriptor))
  (cl:when (cl:logbitp 0 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'air-conditioned) (cl:slot-value from 'air-conditioned))
    (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))
  (cl:when (cl:logbitp 1 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'wheelchair-accessible) (cl:slot-value from 'wheelchair-accessible))
    (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1))
  (cl:when (cl:logbitp 2 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'vehicle-model) (cl:slot-value from 'vehicle-model))
    (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 1))
  (cl:when (cl:logbitp 3 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'performing-prior-trip) (cl:slot-value from 'performing-prior-trip))
    (cl:setf (cl:ldb (cl:byte 1 3) (cl:slot-value self '%has-bits%)) 1))
  (cl:when (cl:logbitp 4 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'special-vehicle-attributes) (cl:slot-value from 'special-vehicle-attributes))
    (cl:setf (cl:ldb (cl:byte 1 4) (cl:slot-value self '%has-bits%)) 1))
)


